<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git</title>
    <url>/2023/08/25/Git/</url>
    <content><![CDATA[<h1 id="GIT-概括"><a href="#GIT-概括" class="headerlink" title="GIT 概括"></a>GIT 概括</h1><h2 id="GIT-介绍"><a href="#GIT-介绍" class="headerlink" title="GIT 介绍"></a>GIT 介绍</h2><p>在代码开发过程中，往往需要对源码进行多次的修改操作，这样一来同一份代码就产生了多个版本，在开发过程中通常需要对这些多个版本代码进行管理，以便于在需要时进行 代码回滚、多版本间比较、多人协作开发、代码分支、分支合并 等操作。这样的需求大量的存在，而随着软件越来越复杂、代码越来越多、参与开发者越来越多，版本管理也变的越来越有难度，此时就需要专业的软件来对版本进行管理，这个过程就称之为版本控制，实现版本控制的软件就称之为<strong>版本控制软件</strong>。</p>
<h1 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h1><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>将每一个管理的文件夹看成workspace(工作空间,相当于idea管理的一个项目)</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>创建了一个当前工作空间的本地库.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814092444841.png" alt="image-20230814092444841" style="zoom:50%;" />

<p>idea中有git插件,一般不需要执行git init</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814092740304.png" alt="image-20230814092740304" style="zoom:50%;" />

<h2 id="配置开发人员信息"><a href="#配置开发人员信息" class="headerlink" title="配置开发人员信息"></a>配置开发人员信息</h2><p>在多人协作中,每人负责的内容不一样,为了方便管理大家上传,修改,删除的操作步骤和历史版本,一般每个用户都会配置自己的开发人员信息.</p>
<p>用法:</p>
<p>用户级别的配置</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git config user.name [xiao]</span><br><span class="line">git config user.email **@qq.com]</span><br></pre></td></tr></table></figure>

<p>全局级别的配置</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git config --global user.name </span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>

<h2 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h2><p>git仓库模型,理论基础</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814094053106.png" alt="image-20230814094053106" style="zoom:50%;" />

<p>在工作区修改添加文件,做项目开发,大量文件代码发生变动.</p>
<p>可以将变动的文件添加到暂存区.</p>
<img src="D:/IDEA/IdeaProjects/jsd2304-notes/notes/DAY01/images/image-20230814094413068.png" alt="image-20230814094413068" style="zoom:50%;" />

<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git add [文件]</span><br></pre></td></tr></table></figure>

<p>文件必须是工作区的文件.可以使用* 代表所有文件.</p>
<p>idea操作add</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814094905018.png" alt="image-20230814094905018" style="zoom:50%;" />

<p>idea发现某些项目是git仓库的话,在创建项目代码时,修改项目代码时,都会提示</p>
<p>是否自动add.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814103024802.png" alt="image-20230814103024802" style="zoom:50%;" />

<h2 id="查看工作区暂存区状态"><a href="#查看工作区暂存区状态" class="headerlink" title="查看工作区暂存区状态"></a>查看工作区暂存区状态</h2><p>观察工作空间的文件变动的情况</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>idea用法:暂无</p>
<h2 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h2><p>执行git命令,将<strong>暂存区</strong>的内容,添加到版本库的<strong>分支区</strong>.</p>
<p>一旦添加到分支区,当前的数据,永不丢失.</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;描述信息&quot;</span><br></pre></td></tr></table></figure>

<p>idea操作</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814095924553.png" alt="image-20230814095924553" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814095733682.png" alt="image-20230814095733682" style="zoom:50%;" />

<h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>commit提交的版本,每一个版本都默认生成一个唯一字符串作为版本号存在.</p>
<p>可以通过log命令,查看当前版本库中信息.</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

 <img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814102659036.png" alt="image-20230814102659036" style="zoom: 33%;" />

<p>idea log功能更强大</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814103644472.png" alt="image-20230814103644472" style="zoom:50%;" />

<h2 id="版本的回滚"><a href="#版本的回滚" class="headerlink" title="版本的回滚"></a>版本的回滚</h2><p>在commit多次提交的version版本中,我们可以从一个当前版本跳转回滚到另一个版本.</p>
<p>用法</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git reset [--hard|soft|mixed] version版本号</span><br></pre></td></tr></table></figure>

<p>选项是有默认值的.–mixed.</p>
<ul>
<li>hard 表示直接回滚到对应version的版本,所有不同文件,不同内容丢失</li>
<li>soft 回退到对应版本,但是不同的内容保存在暂存区</li>
<li>mixed回退到对应版本,但是不同的内容保存在工作区</li>
</ul>
<p>idea的操作</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814104730716.png" alt="image-20230814104730716" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814104802829.png" alt="image-20230814104802829" style="zoom:50%;" />

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>一旦选择回滚,在git log命令中,就看不到后续的版本了.</p>
<p>如果想要回滚回去(逻辑上讲,不会出现这种操作)</p>
<p>idea 操作 对比版本区别</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814105214981.png" alt="image-20230814105214981" style="zoom:50%;" />

<p>用法</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git tag 标签名 版本号</span><br></pre></td></tr></table></figure>

<h2 id="查看操作版本值日"><a href="#查看操作版本值日" class="headerlink" title="查看操作版本值日"></a>查看操作版本值日</h2><p>如果在当前版本之后有很多版本(因为回退),想查看后面版本 git log做不到</p>
<p>可以使用git reflog</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/git%E5%91%BD%E4%BB%A4%E5%92%8C%E6%A6%82%E5%BF%B5.png" alt="git命令和概念"></p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h2><p>分支,为了避免同一个仓库,多人协作开发时,重复,冗余解决文件冲突问题,引出的一个git特性-分支.</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>默认情况下,每个git仓库有一个默认分支 master.</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git branch 新分支名称</span><br></pre></td></tr></table></figure>

<p>在git仓库分支区就会多出一个分支区名字 新分支名字.和执行命令时所在的分支,共享同一个版本作为 base version</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814144051471.png" alt="image-20230814144051471" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814144318865.png" alt="image-20230814144318865" style="zoom:50%;" />

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p><strong>注意</strong>: 新学习git的时候,切换分支之前,先提交版本,不在工作区和暂存区有一些新变化的时候切换.</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git checkout 目标分支名称</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814144541545.png" alt="image-20230814144541545" style="zoom:50%;" />

<p>通过上述两个命令,创建分支,切换分支,就可以在不同分支.</p>
<p>在master和branch1中分别提交一个版本,最终分支的结构</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814145032505.png" alt="image-20230814145032505" style="zoom:50%;" />

<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>在git中可以通过命令查看当前git仓库的所有分支,和正在使用的分支.</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814145347049.png" alt="image-20230814145347049" style="zoom:50%;" />

<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>分支开发完毕,可以将分支进行合并,所有版本合并到一起</p>
<p>执行合并命令,分清楚谁合并到谁</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git merge 目标分支</span><br></pre></td></tr></table></figure>

<p>目标分支的意思并不是<strong>合并到</strong>的分支,而是要拉过来合并的那个分支.</p>
<p>执行merge命令所在分支,是合并到的分支.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814151822732.png" alt="image-20230814151822732" style="zoom:50%;" />

<p>在master执行merge合并,最终版本 ,分支的关系</p>
<img src="D:/IDEA/IdeaProjects/jsd2304-notes/notes/DAY01/images/image-20230814152236216.png" alt="image-20230814152236216" style="zoom:50%;" />

<p>如果继续在branch1中合并master,分支结构图</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814152925266.png" alt="image-20230814152925266" style="zoom:50%;" />

<h2 id="合并分支解决冲突-重点"><a href="#合并分支解决冲突-重点" class="headerlink" title="合并分支解决冲突(重点)"></a>合并分支解决冲突(重点)</h2><p>冲突一定是出现在以下条件里的:</p>
<ul>
<li>文件相同(两个,多个分支同时提交的版本中有文件)</li>
<li>行冲突</li>
</ul>
<p>同时满足上述2个条件,就需要在merge的时候解决冲突问题</p>
<p>解决冲突有2中</p>
<ol>
<li>git命令解决</li>
<li>idea</li>
</ol>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git merge branch1</span><br></pre></td></tr></table></figure>

<p>由于冲突存在.</p>
<p><img src="D:/IDEA/IdeaProjects/jsd2304-notes/notes/DAY01/images/image-20230814153636249.png" alt="image-20230814153636249"></p>
<p>合并暂停,git会在冲突的文件中,给标记对应冲突内容,需要人为的手动调整.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814153809071.png" alt="image-20230814153809071" style="zoom:50%;" />

<p>调整完成后,合并继续</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git add *</span><br><span class="line">git merge --continue</span><br></pre></td></tr></table></figure>

<p>合并后,git跳转到一个日志文件,记录合并的过程</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814154311722.png" alt="image-20230814154311722" style="zoom:33%;" />

<p>涉及到linux命令操作.从文件中退出</p>
<ol>
<li>ESC</li>
<li>直接在键盘输入 :wq</li>
<li>回车</li>
</ol>
<p>推荐使用idea,更智能,更方便.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814154839747.png" alt="image-20230814154839747" style="zoom:50%;" />

<p>一旦出现冲突,idea会自动提出解决冲突的方案</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814155414932.png" alt="image-20230814155414932" style="zoom: 50%;" />

<p>三个选择方案前两种,保留当前分支内容,或保留目标分支内容</p>
<p>第三种方案 手动调整.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814155715948.png" alt="image-20230814155715948" style="zoom: 33%;" />

<h2 id="合并分支-冲突解决的练习"><a href="#合并分支-冲突解决的练习" class="headerlink" title="合并分支,冲突解决的练习"></a>合并分支,冲突解决的练习</h2><ul>
<li>需要多个分支<ul>
<li>创建分支 git branch 名字</li>
</ul>
</li>
<li>不同分支提交不同版本<ul>
<li>切换分支 git checkout 名字</li>
<li>查看当前所在分支 git branch</li>
</ul>
</li>
<li>满足冲突条件<ul>
<li>1相同文件,2行冲突</li>
<li>尝试相同文件,没有行冲突,会不会有冲突解决的需求</li>
</ul>
</li>
</ul>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="远程仓库概念"><a href="#远程仓库概念" class="headerlink" title="远程仓库概念"></a>远程仓库概念</h2><p>团队做开发的时候,每个人都管理自己的本地版本.</p>
<p>如果是协作开发,应该是每人负责不同的项目功能,最终合并到一起使用.</p>
<p>多个git仓库的管理工作,涉及到一个概念–远程仓库</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814164641355.png" alt="image-20230814164641355" style="zoom:50%;" />

<h2 id="谁是远程仓库"><a href="#谁是远程仓库" class="headerlink" title="谁是远程仓库"></a>谁是远程仓库</h2><p>git中提到去中心化的概念.</p>
<ul>
<li>中心化结构</li>
</ul>
<p>svn典型软件</p>
<p>每个人只管理自己的内容.</p>
<p>最终都在中心服务器进行代码的整理.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814165127503.png" alt="image-20230814165127503" style="zoom:50%;" />

<p>存在缺点</p>
<ol>
<li>依赖性太强</li>
<li>单点故障</li>
</ol>
<ul>
<li>去中心化结构</li>
</ul>
<p>git典型的软件之一.(最终使用的感受,还是中心化)</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814165807896.png" alt="image-20230814165807896" style="zoom:50%;" />

<p>git存在中心托管仓库的概念,实际上是不需要个人电脑实现远程仓库的角色的.</p>
<p>github(国内慢,资源非常多)</p>
<p>gitee(国内的github)</p>
<p>gitlab 公司内部服务器(代码不开源)</p>
<h2 id="gitee使用远程仓库"><a href="#gitee使用远程仓库" class="headerlink" title="gitee使用远程仓库"></a>gitee使用远程仓库</h2><h3 id="远程仓库和本地做关联"><a href="#远程仓库和本地做关联" class="headerlink" title="远程仓库和本地做关联"></a>远程仓库和本地做关联</h3><p>本地创建一个项目</p>
<p>在项目中准备好git本地仓库,可以和远程仓库做关联,然后 pull&#x2F;push了.</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git remote </span><br></pre></td></tr></table></figure>

<p>查看本地仓库关联的远程仓库.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230814171537401.png" alt="image-20230814171537401" style="zoom:50%;" />

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git remote add 远程仓库名称 远程仓库git地址</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git remote add abc https://gitee.com/xiaolao</span><br><span class="line">shi2021/project-01.git</span><br></pre></td></tr></table></figure>

<h3 id="push-pull"><a href="#push-pull" class="headerlink" title="push&#x2F;pull"></a>push&#x2F;pull</h3><p>push命令,将本地分支版本推送到远程仓库.push如果有冲突,需要先解决冲突(pull)</p>
<p>在远程仓库中也有分支</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git push 远程仓库的名称 本地分支:远程分支</span><br></pre></td></tr></table></figure>

<p>我要将,本地分支 推送到abc这个远程仓库的远程分支</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git push abc master:main</span><br></pre></td></tr></table></figure>



<p>如果多人协作,还有别人在main远程分支推送代码(如何在本地模拟多人协作连接同一个远程分支)</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git pull 远程仓库名称 远程分支名称</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git pull abc main</span><br></pre></td></tr></table></figure>

<p>执行操作的时候,会先从远程中心 拉取main分支的版本,在和本地当前所在分支做merge合并.</p>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>git提供命令 对远程分支进行fetch抓取操作.</p>
<p>本质 fetch 连接远程仓库,将更新的内容抓取到远程分支记录.没有实际的任何变动数据</p>
<p>用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">git fetch 仓库名 远程分支名</span><br></pre></td></tr></table></figure>

<p>只负责从远程仓库 <strong>抓取到本地记录远程变动</strong>,并不负责将变动内容<strong>合并</strong>到本地分支</p>
<p>看出来和执行pull的区别.</p>
<p><strong>pull 分支&#x3D;fetch(分支)+merge(分支)</strong></p>
<p>当远程仓库出现新的分支的时候,可以使用fetch第一次抓取过来. 不要直接使用pull.</p>
<h1 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h1><p>企业开发过程中,总是满足一种比较规范的分支管理策略(所有分支操作,包括远程,都已经在上述的命令,案例中介绍了).</p>
<ul>
<li><p><strong>gitflow</strong>: 最老版本,最规范的分支使用策略,满足<strong>版本发布</strong>特点</p>
</li>
<li><p>githubflow: 满足持续发布</p>
</li>
<li><p>gitlabflow: 既能满足版本发布,又能满足持续发布</p>
</li>
</ul>
<p><strong>版本发布</strong>: 游戏 v1.0.8 v1.1.0</p>
<p><strong>持续发布</strong>: web网站(<strong>灰度发布</strong>)</p>
<p>核心都是分开开发,定义分支的意义(<strong>gitflow</strong>定义分支的使用<strong>规范</strong>最全)</p>
<ol>
<li>永久分支:</li>
</ol>
<ul>
<li>master&#x2F;main: 保管的永远是稳定代码版本(几乎没有bug),什么时候代码测试的差不多了,才能合并到master.</li>
<li>develop&#x2F;dev: 开发分支,所有功能推进都<strong>基于</strong>develop进行</li>
</ul>
<ol start="2">
<li>临时分支(分支使用完毕,要删除)</li>
</ol>
<ul>
<li><p>feature-XX: 新功能分支,来自于develop,XX可以是人名,可以是功能名称,不同的开发人员开发维护不同feature分支,最终合并到develop,删除</p>
</li>
<li><p>release分支: 保护分支,来自于develop,目的是测试develop不影响develop开发,如果测试有问题,修改bug,合并到deveop和master,在master做版本最终上线(合并到master意味着代码要上线),归宿一定是master,也会合并dev.</p>
</li>
<li><p>hot-fix: 热点修复,解决线上bug,来自于master,归宿一定是master和develop</p>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230815105554961.png" alt="image-20230815105554961"></p>
]]></content>
      <categories>
        <category>常用工具和框架</category>
      </categories>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/2023/08/20/Dubbo/</url>
    <content><![CDATA[<h1 id="Dubbo远程调用"><a href="#Dubbo远程调用" class="headerlink" title="Dubbo远程调用"></a>Dubbo远程调用</h1><h2 id="概念介绍dubbo-RPC"><a href="#概念介绍dubbo-RPC" class="headerlink" title="概念介绍dubbo&amp;RPC"></a>概念介绍dubbo&amp;RPC</h2><p>Dubbo 是一种基于 RPC（Remote Procedure Call，远程过程调用）的框架，用于构建分布式的服务化应用。RPC 是一种通信协议，允许一个程序在不同的计算机上通过网络调用另一个程序的方法或函数。</p>
<p>Dubbo 的概念：</p>
<p>Dubbo 是由阿里巴巴集团开发和维护的高性能的、基于 Java 的开源 RPC 框架。它提供了服务调用和服务治理的解决方案，用于构建分布式系统和微服务架构。Dubbo 具有以下特点：</p>
<p>RPC 的概念：</p>
<p>RPC 是一种远程过程调用的协议，用于实现不同计算机上程序之间的通信和方法调用。它的基本思想是将远程方法的调用封装成本地方法调用，使得远程方法对开发人员来说具有透明性。</p>
<h2 id="dubbo结构流程"><a href="#dubbo结构流程" class="headerlink" title="dubbo结构流程"></a>dubbo结构流程</h2><ul>
<li><p>服务协调者: 注册中心(管理的数据是dubbo框架流程中的 provider和consumer)</p>
</li>
<li><p>服务提供者provider: (cart&#x2F;stock) 整合dubbo组件,连接nacos协调者进行provider功能注册.</p>
</li>
<li><p>服务消费者consumer: (order) 整合dubbo组件,连接nacos协调者进行provider抓取</p>
</li>
<li></li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817170450535.png" alt="image-20230817170450535" style="zoom:50%;" />

<h2 id="分角色整合Dubbo"><a href="#分角色整合Dubbo" class="headerlink" title="分角色整合Dubbo"></a>分角色整合Dubbo</h2><p>stock整合dubbo</p>
<p>为什么要整合dubbo: 作为远程调用流程的provider 整合dubbo才能实现注册.才能通过dubbo框架被rpc远程调用.</p>
<ol>
<li>依赖(完成)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--底层dubbo版本2.7.8--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>yaml配置(完成)</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dubbo相关属性</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 为dubbo配置的应用名称,一般情况下 和spring 一样</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-luban-demo-stock</span></span><br><span class="line">    <span class="comment"># qos端口关闭 qos是dubbo提供的一套api接口,允许自定义项目监听连接dubbo</span></span><br><span class="line">    <span class="attr">qos-enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 作为dubbo结构的一员,总要连接注册中心</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="comment"># dubbo底层读取属性,会解析协议名称,根据协议名称</span></span><br><span class="line">    <span class="comment"># 创建了解不同协调器的代码实现 nacos zookeper</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">nacos://localhost:8848</span></span><br><span class="line">    <span class="comment"># spring cloud starter中包含一些我们用不到的属性配置,需要关闭</span></span><br><span class="line">    <span class="comment"># 如果不关闭,不管理,会导致nacos配置文件越来越多</span></span><br><span class="line">    <span class="attr">use-as-config-center:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">use-as-metadata-center:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="comment"># rpc底层通信协议 默认使用dubbo提供的性能最高的,匹配兼容最好的dubbo协议</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="comment"># 定义这个协议的端口名称 -1 会检查当前系统已经占用了从20880开始的哪个端口</span></span><br><span class="line">    <span class="comment"># 做递增处理</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment"># 在没有明确调用关系 消费关系时,暂时让dubbo spring客户端订阅空</span></span><br><span class="line">    <span class="attr">subscribed-services:</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注解</li>
</ol>
<p>做注解的使用之前,要明确<strong>provider是谁</strong>,提供了哪些功能</p>
<p>明确,<strong>consumer是谁</strong>,调用了哪些功能</p>
<p>stock项目为例:</p>
<ul>
<li>provider: 被order调用 减库存</li>
<li>com.tarena.luban.demo.all.serivce.IStockService: reduceCommodityCount</li>
<li>实现类: StockServiceImpl</li>
</ul>
<p>启动类中 定义一个注解的使用</p>
<p>@EnableDubbo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.demo.all.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.tarena.luban.demo.all&quot;,&quot;com.tarena.luban.commons.exception&quot;&#125;)</span></span><br><span class="line"><span class="comment">//但凡叫做Enable的注解,都是在额外的导入配置逻辑</span></span><br><span class="line"><span class="comment">//扫描 provider注解和consumer的注解</span></span><br><span class="line"><span class="comment">//根据配置dubbo远程注册中心,实现信息注册</span></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AllApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在提供者的实现逻辑代码中(StockServiceImpl) 添加provider注解</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818095855160.png" alt="image-20230818095855160"></p>
<h2 id="启动注册信息"><a href="#启动注册信息" class="headerlink" title="启动注册信息"></a>启动注册信息</h2><p>stock启动,会发现nacos出现多条注册信息,其中luban-demo-stock是nacos客户端注册信息,不参与dubbo远程调用的.</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818101909288.png" alt="image-20230818101909288"></p>
<p>provider: 当前注册的角色是提供者</p>
<p>com.tarena.luban.demo.all.service.IStockService: 允许远程建立连接调用的接口</p>
<p>选择这个dubbo注册 信息详情</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818102026204.png" alt="image-20230818102026204"></p>
<p>详情里记录了这个provider实例的所有允许远程调用需要抓取的必要条件.</p>
<p>核心 ip:port 接口和方法.</p>
<h2 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h2><p>在provider的进程中,会根据dubbo信息 开启一个dubboSocket服务. 占用dubbo协议端口 ,等待调用者建立连接访问实现方法 addUser() reduceCommodityCount();</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818103137244.png" alt="image-20230818103137244"></p>
<h2 id="dubbo整合consumer"><a href="#dubbo整合consumer" class="headerlink" title="dubbo整合consumer"></a>dubbo整合consumer</h2><p>consumer端的配置和使用和 provider几乎一模一样的,维度注解有区别</p>
<p>provider端使用的注解叫做@DubboService</p>
<p>consumer端使用的注解叫做@DubboReference</p>
<p> order实现整合</p>
<ol>
<li>依赖</li>
<li>yaml(微调)</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="comment"># 订阅的dubbo 服务(dubbo appplicaiton name)</span></span><br><span class="line">  <span class="attr">subscribed-services:</span> <span class="string">luban-demo-stock</span></span><br><span class="line"><span class="attr">consumer:</span></span><br><span class="line">  <span class="comment"># dubbo有调用关系的结构中,默认情况下 consumer会检查provider是否启动</span></span><br><span class="line">  <span class="comment"># 将这个检查关闭. 但是如果可以做到,还是最好先启动provider</span></span><br><span class="line">  <span class="attr">check:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注解的使用</li>
</ol>
<p>当前项目 的角色 order-consumer 消费者调用者</p>
<p>当前项目调用的功能 @Autowired(required&#x3D;false) IStockService</p>
<ul>
<li>启动类</li>
</ul>
<p>@EnableDubbo</p>
<ul>
<li>调用逻辑属性对象上IStockService添加注解</li>
</ul>
<p>@DubboReference</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818104416943.png" alt="image-20230818104416943"></p>
<h2 id="order启动注册信息"><a href="#order启动注册信息" class="headerlink" title="order启动注册信息"></a>order启动注册信息</h2><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818104934947.png" alt="image-20230818104934947"></p>
<p>明确的表示了 stock作为provider向外提供IStockService实现的</p>
<p>order作为consumer需要调用IStockService</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818105933517.png" alt="image-20230818105933517"></p>
<p>provider整合dubbo:</p>
<ol>
<li>注册在nacos(向外声明可以提供功能)</li>
<li>建立了一个dubboSocket 开启外界调用的入口</li>
<li>实现类就等着被dubboSocket调用</li>
</ol>
<p>consumer整合dubbo:</p>
<ol>
<li>抓取的nacos信息</li>
<li>本地根据nacos中的需要的信息IStockService 建立代理</li>
<li>代码中调用的接口实际调用代理</li>
<li>代理底层根据抓取的信息建立和provider的连接</li>
</ol>
<h2 id="cart整合"><a href="#cart整合" class="headerlink" title="cart整合"></a>cart整合</h2><p>思考:</p>
<ol>
<li>什么角色: provider</li>
<li>暴露接口: ICartService</li>
</ol>
<p>整合cart:</p>
<ol>
<li><p>依赖</p>
</li>
<li><p>yaml(微调)</p>
</li>
<li><p>注解</p>
</li>
</ol>
<ul>
<li>@EnableDubbo 启动类</li>
<li>@DubbuService provider 实现类注解 暴露</li>
</ul>
<p>修改order:</p>
<ol>
<li>yaml 微调(订阅2个服务)</li>
<li>serviceImpl @DubboRefrerence的使用</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230818113755703.png" alt="image-20230818113755703"></p>
<h2 id="启动验证调用"><a href="#启动验证调用" class="headerlink" title="启动验证调用"></a>启动验证调用</h2><ul>
<li>访问购物车接口 新增购物车()</li>
<li>访问订单接口 新增订单</li>
</ul>
<h2 id="为什么远程调用不使用HTTP"><a href="#为什么远程调用不使用HTTP" class="headerlink" title="为什么远程调用不使用HTTP"></a>为什么远程调用不使用HTTP</h2><ul>
<li><p>能不能使用HTTP 做order调用cart stock的实现</p>
<ul>
<li>可以的</li>
</ul>
</li>
<li><p>遵循一个微服务架构中远程调用的方案的原则:</p>
<ul>
<li><p>对内RPC(性能)</p>
</li>
<li><p>对外HTTP(规范)</p>
<ul>
<li>nacos客户端还用不用(对外http的时候要用到nacos的注册信息)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Dubbo负载均衡"><a href="#Dubbo负载均衡" class="headerlink" title="Dubbo负载均衡"></a>Dubbo负载均衡</h1><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>在微服务,分布式集群中,远程调用采用dubbo框架,调用的过程要实现负载均衡,因为每一个服务的实例都是集群结构.</p>
<p>负载: 访问并发,流量,请求 都可以称为负载(存储).</p>
<p>均衡: 集群分布式环境下,将负载压力 做逻辑均衡的分配.</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821092949921.png" alt="image-20230821092949921"></p>
<h2 id="dubbo负载均衡策略"><a href="#dubbo负载均衡策略" class="headerlink" title="dubbo负载均衡策略"></a>dubbo负载均衡策略</h2><ul>
<li>random: 随机(默认)</li>
<li>roundRobin: 轮询</li>
<li>leastactive: 最小活跃分配负载均衡,越闲,分配的越多</li>
</ul>
<h2 id="dubbo负载均衡配置"><a href="#dubbo负载均衡配置" class="headerlink" title="dubbo负载均衡配置"></a>dubbo负载均衡配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>指的是在一个项目中的yaml文件中配置负载均衡,分为provider和consumer的角色</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">	<span class="attr">provider:</span></span><br><span class="line">		<span class="attr">loadbalance:</span> <span class="string">random</span></span><br><span class="line">	<span class="attr">consumer:</span></span><br><span class="line">		<span class="attr">loadbalance:</span> <span class="string">random</span></span><br></pre></td></tr></table></figure>

<h3 id="局部配置"><a href="#局部配置" class="headerlink" title="局部配置"></a>局部配置</h3><p>指的是在类的注解中配置负载均衡,分为provider和consumer的角色</p>
<p>provider注解配置负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService(loadbalance = &quot;roundrobin&quot;)</span></span><br></pre></td></tr></table></figure>

<p>consumer注解配置负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboReference(loadbalance = &quot;roundrobin&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="负载均衡配置优先级"><a href="#负载均衡配置优先级" class="headerlink" title="负载均衡配置优先级"></a>负载均衡配置优先级</h3><p>几乎碰到所有的冲突配置,逻辑关系到优先级的时候,都以<strong>以更精准为更优先</strong>.</p>
<p>局部配置&gt;全局配置</p>
<p>provider配置&gt;consumer配置</p>
<p>局部provider&gt;局部consumer&gt;全局provider&gt;全局consumer</p>
<h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>观察dubbo能够实现的负载均衡</p>
<p>目标: 搭建启动一个stock集群,每个实现代码标注一下调用端口</p>
<p>order新增案例,调用stock做负载均衡(20次访问,基本每个stock都有调用痕迹)</p>
<ul>
<li>启动多个stock实例</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821095349173.png" alt="image-20230821095349173"></p>
<p>启动配置项,可以启动test配置项,main方法配置项,spring应用,springboot web应用…</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821101244982.png" alt="image-20230821101244982"></p>
<p><strong>注意</strong>: 如果是2022版本的idea 在启动配置项的右上侧有一个<strong>modify options</strong>选项.</p>
<p>勾选override parameters就能看到.</p>
<p>dubbo框架 springmvc myabtis nacos组件 所有的应用,都使用到了一种底层逻辑: springboot自动配置.</p>
]]></content>
      <categories>
        <category>微服务相关组件</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/09/11/Linux/</url>
    <content><![CDATA[<h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开发过程中所运行的几乎所有软件进程,都要最终在服务器上<strong>部署</strong></p>
<ul>
<li>nacos</li>
<li>rocketmq<ul>
<li>namesrv</li>
<li>borker</li>
</ul>
</li>
<li>redis<ul>
<li>单机</li>
<li>sentinel哨兵</li>
<li>cluster集群</li>
</ul>
</li>
<li>mysql<ul>
<li>单机</li>
<li>集群</li>
</ul>
</li>
<li>项目jar包<ul>
<li>java -jar worker.jar -Xms128M –server.port&#x3D;8090</li>
</ul>
</li>
<li>前端<ul>
<li>配合其它网关 http服务软件 搭建静态页面</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911091550289.png" alt="image-20230911091550289"></p>
<h2 id="linux系统介绍"><a href="#linux系统介绍" class="headerlink" title="linux系统介绍"></a>linux系统介绍</h2><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="什么是虚拟机"><a href="#什么是虚拟机" class="headerlink" title="什么是虚拟机"></a>什么是虚拟机</h3><p>Linux，一般指GNU&#x2F;Linux（单独的Linux内核并不可直接使用，一般搭配GNU套件，故得此称呼），是一种免费使用和自由传播的<a href="https://baike.baidu.com/item/%E7%B1%BBUNIX/9032872?fromModule=lemma_inlink">类UNIX</a>操作系统，其内核由<a href="https://baike.baidu.com/item/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%9C%AC%E7%BA%B3%E7%AC%AC%E5%85%8B%E7%89%B9%C2%B7%E6%89%98%E7%93%A6%E5%85%B9/1034429?fromModule=lemma_inlink">林纳斯·本纳第克特·托瓦兹</a>（Linus Benedict Torvalds）于1991年10月5日首次发布，它主要受到<a href="https://baike.baidu.com/item/Minix/7106045?fromModule=lemma_inlink">Minix</a>和<a href="https://baike.baidu.com/item/Unix/219943?fromModule=lemma_inlink">Unix</a>思想的启发，是一个基于<a href="https://baike.baidu.com/item/POSIX/3792413?fromModule=lemma_inlink">POSIX</a>的多用户、<a href="https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1/1011764?fromModule=lemma_inlink">多任务</a>、支持<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fromModule=lemma_inlink">多线程</a>和多<a href="https://baike.baidu.com/item/CPU/120556?fromModule=lemma_inlink">CPU</a>的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>。它支持<a href="https://baike.baidu.com/item/32%E4%BD%8D/5812218?fromModule=lemma_inlink">32位</a>和<a href="https://baike.baidu.com/item/64%E4%BD%8D/2262282?fromModule=lemma_inlink">64位</a>硬件，能运行主要的<a href="https://baike.baidu.com/item/Unix/219943?fromModule=lemma_inlink">Unix</a>工具软件、应用程序和网络协议。</p>
<p>Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。<strong>Linux有上百种不同的发行版</strong>，如基于社区开发的<a href="https://baike.baidu.com/item/debian/748667?fromModule=lemma_inlink">debian</a>、<a href="https://baike.baidu.com/item/archlinux/10857530?fromModule=lemma_inlink">archlinux</a>，和基于商业开发的[Red Hat Enterprise Linux](<a href="https://baike.baidu.com/item/Red">https://baike.baidu.com/item/Red</a> Hat Enterprise Linux&#x2F;10770503?fromModule&#x3D;lemma_inlink)、<a href="https://baike.baidu.com/item/SUSE/60409?fromModule=lemma_inlink">SUSE</a>、[Oracle Linux](<a href="https://baike.baidu.com/item/Oracle">https://baike.baidu.com/item/Oracle</a> Linux&#x2F;6876458?fromModule&#x3D;lemma_inlink)等。</p>
<p>版本不同差别还是非常大的.</p>
<p>rehat centos&#x3D;rockeyList(一个作者) ubantu Debian Fedora 等等.</p>
<p>在开发岗位使用的linux没有图形界面的,虽然Linux很多版本支持图形界面的.但是不要以windows使用习惯,操作和理解linux.</p>
<h3 id="虚拟机网络"><a href="#虚拟机网络" class="headerlink" title="虚拟机网络"></a>虚拟机网络</h3><p>虚拟机是一个可以在已有的物理机上的操作系统中,创建独立隔离的一个单独操作系统的虚拟化软件.</p>
<p>虚拟机的概念和结构</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911093310492.png" alt="image-20230911093310492"></p>
<p>如果想要通过宿主机 寻找管理使用虚拟机系统中的文件和软件.</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911093548657.png" alt="image-20230911093548657"></p>
<p>所有的操作系统想要对外访问,允许外部连接,都需要通过网络(ip地址).</p>
<p>一定要通过网卡来连接.</p>
<p>虚拟机也有网卡-虚拟网卡</p>
<p>真实物理机网卡</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911095013469.png" alt="image-20230911095013469"></p>
<h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>finalShell 作为开发工程师,运维工程师操作远程服务器的客户端,建立安全的网络连接.</p>
<h2 id="Linux系统基础命令"><a href="#Linux系统基础命令" class="headerlink" title="Linux系统基础命令"></a>Linux系统基础命令</h2><h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>登录进入linux直接看到的提示符行</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911095211876.png" alt="image-20230911095211876" style="zoom:50%;" />

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[&#123;当前登录用户&#125;@&#123;当前主机名&#125; &#123;当前命令提示符所在文件夹名称&#125;]#</span><br></pre></td></tr></table></figure>

<ul>
<li>当前用户: root最高级别权限的用户,这个平时开发时不可能拿得到.都会给不同的开发者使用不同权限账号 比如 zhangsan lisi</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[zhangsan@rockylinux8 home]$</span><br></pre></td></tr></table></figure>

<p>除了最高权限用户root的后缀是# 其它用户全部都是$符号.</p>
<p>可以通过账号密码进行用户的切换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure>

<p><strong>测试切换</strong></p>
<ol>
<li>添加一个用户</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd xiaolaoshi</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在root切换到新用户</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su xiaolaoshi</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911101756607.png" alt="image-20230911101756607" style="zoom:50%;" />

<ol start="3">
<li>从当前用户退出</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>从新用户su到root用户,需要输入密码</li>
</ol>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911102113629.png" alt="image-20230911102113629" style="zoom:50%;" />

<p><strong>主机名</strong></p>
<p>直接输入命令可以查看主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure>

<p>如果命令后面添加一个参数 相当于临时修改主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostname jsd2304</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911102353291.png" alt="image-20230911102353291" style="zoom:50%;" />

<p><strong>当前文件夹</strong></p>
<p>~ 表示当前用户的家目录 ${USER.HOME}</p>
<p>所以同时是在&#x2F;root目录下,root用户看到~ xiaolaoshi新用户看到 root</p>
<p>新用户创建之后,家目录总是在**&#x2F;home&#x2F;{用户名称}**</p>
<p><strong>权限标识符号</strong></p>
<p>$ 表示普通权限</p>
<p># 表示最高权限</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><ul>
<li><strong>演示一些命令</strong></li>
</ul>
<p>在linux系统中,存在非常多的使用命令.命令格式比较统一</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;主命令&#125; [选项] [参数]</span><br></pre></td></tr></table></figure>

<p>例如: 有的命令只有主命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>查看当前所在的路径全路径名称</p>
<p>linux中没有盘符的概念.所以所有地址和所有文件都是以”&#x2F;“开始的绝对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<p>检查当前所在目录中所有的内容. ls&#x3D;list展示列表.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911103608735.png" alt="image-20230911103608735" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a /home</span><br></pre></td></tr></table></figure>

<p>表示查看&#x2F;home这个目录下的所有文件内容.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911103655615.png" alt="image-20230911103655615" style="zoom:50%;" />

<ul>
<li>命令帮助</li>
</ul>
<p>绝大部分密令使用的时候 都存在帮助菜单.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;命令&#125; --help</span><br></pre></td></tr></table></figure>

<p>展示命令的用法Usage,和命令的所有选项以及选项解释.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls --help</span><br></pre></td></tr></table></figure>

<p>对于基础命令的学习,更建议使用现成的书,比在系统中使用–help来的更直接,学习更全面和系统.</p>
<h3 id="cd-指令"><a href="#cd-指令" class="headerlink" title="cd 指令"></a>cd 指令</h3><p>cd更改当前工作所在的目录,从当前目录 转向目标目录中.</p>
<p>所以如果想要随心所欲的修改目录,跳转,需要对linux的目录结构有最基本的认识.</p>
<p>例如:</p>
<p>&#x2F; 下有哪些常用的目录</p>
<ul>
<li>home: 用户家目录的上级目录,所有创建的新用户都在这里出现家目录</li>
<li>root: root账号的家目录</li>
<li>etc: 环境目录 比如环境变量,一些环境配置文件,网络网卡</li>
<li>usr: 工作用户目录,包含不同用户的环境配置命令</li>
<li>var: 变量目录,有一些软件安装默认配置就在这里,下载,docker容器,数据卷</li>
<li>sbin&#x2F;bin目录: 系统命令所在的文件夹,命令文件脚本</li>
</ul>
<ol>
<li><strong>相对路径和绝对路径</strong></li>
</ol>
<p>在使用linux系统的时候,无论去寻找 ,使用,指定 <strong>文件或者文件夹</strong>,有两种编写路径的方式. <strong>相对路径(相对于当前工作路径) 绝对路径(一切都是从&#x2F;开始的)</strong></p>
<p>例如: 使用ls命令 查看home文件夹的东西</p>
<p><strong>相对路径</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls ../home</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911104909518.png" alt="image-20230911104909518" style="zoom:50%;" />

<p>由于当前工作路径在root下,所以 相对路径找到home 需要向上一级目录 ..&#x2F; 在加上home才能看到</p>
<p><strong>绝对路径</strong></p>
<p>所有的文件或者文件夹的绝对路径一定是 &#x2F;开始的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure>

<p>由于使用绝对路径,所以无论当前工作空间在哪里,都不影响执行js展示&#x2F;home内容的命令结果.</p>
<p>所以一下的cd命令哪个使用的相对路径 哪个是使用的绝对路径,含义是什么</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home</span><br><span class="line">cd ../../../home</span><br><span class="line">cd /home/soft</span><br></pre></td></tr></table></figure>

<p>补充上述cd命令的描述含义:</p>
<ol>
<li><p>绝对路径 直接寻找 &#x2F;home目录</p>
</li>
<li><p>相对路径,相对于当前文件夹 向上三级 向下寻找home</p>
</li>
<li><p>绝对路径 直接寻找&#x2F;home&#x2F;soft目录</p>
</li>
</ol>
<h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><p><strong>作用</strong>:展示文件夹中的内容的指令,或者展示某个 某几个文件的内容.</p>
<p><strong>常见选项</strong>:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-a: 展示目标文件夹下,所有文件内容,目录内容,linux系统中,文件和文件夹的名字带.开始的,都是隐藏的.</span><br><span class="line">-l: 以详情展示</span><br><span class="line">-R: (不要轻易使用) 递归的查看</span><br><span class="line">可以通过参数指定查看的文件夹.展示一个树</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br><span class="line">ls -a /home</span><br><span class="line">ls -a /home/helloWorker.txt</span><br></pre></td></tr></table></figure>

<p>参数类型不同 第一个没有参数 默认当前目录</p>
<p>第二个有参数 &#x2F;home目录</p>
<p>第三个有参数&#x2F;home目录下的一个helloWorker.txt文件</p>
<p>多个选项 如果没有意义上的冲突可以同时使用的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure>

<p>参数可以添加范围匹配.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls *.jar</span><br></pre></td></tr></table></figure>

<p>是在当前目录中,查询所有以.jar结尾的文件.</p>
<h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h3><p><strong>作用:</strong> 创建目录</p>
<p><strong>常用选项</strong>:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-p: 允许创建多级目录,不添加不允许创建.</span><br></pre></td></tr></table></figure>

<p><strong>重点</strong>: 相对路径还是绝对路径的创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /home/haha</span><br><span class="line">mkdir kaka</span><br><span class="line">mkdir -p /home/a/b/c/d/e</span><br></pre></td></tr></table></figure>

<p>如果创建的是空文件夹,并且不需要了,可以使用命令删除</p>
<p><strong>rmdir</strong>: 只能删除空文件夹</p>
<h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><p>创建一个或多个空文件.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch text01.txt text02.txt</span><br></pre></td></tr></table></figure>

<h3 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h3><p><strong>作用:</strong> 拷贝文件夹或者文件到指定文件或指定目录中</p>
<p><strong>用法:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cp [选项] source dest</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong>:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-r 递归赋值,如果没有-r 最多只能复制一个文件,无法赋值有文件的文件夹</span><br></pre></td></tr></table></figure>

<p><strong>排列组合</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cp 文件 目录 : 将文件拷贝到目录</span><br><span class="line">cp 文件 不存在的一个名字: 将文件拷贝成这个新名字的文件</span><br><span class="line">cp -r 文件夹 目录: 将空文件夹拷贝到目录下</span><br><span class="line">cp -r 文件夹 不存在的一个名字: 文件夹会拷贝成新名字的文件夹</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911114300962.png" alt="image-20230911114300962"></p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911114311818.png" alt="image-20230911114311818"></p>
<p>在root文件夹下会出现4个新内容 2个新文件 2个新目录</p>
<p>&#x2F;root&#x2F;text01.txt</p>
<p>&#x2F;root&#x2F;text.txt</p>
<p>&#x2F;root&#x2F;cptest</p>
<p>&#x2F;root&#x2F;hahatest</p>
<h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><p><strong>作用</strong>: 移动 剪切</p>
<p><strong>用法</strong>: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] source dest</span><br></pre></td></tr></table></figure>

<p>所有的内容和cp差不多,</p>
<p>区别之一是,cp的source不会消失,但是mv的会消失.</p>
<p>区别之二是,mv可以支持移动文件夹,无论有没有下级文件.</p>
<h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><p><strong>作用</strong>: 查看文本文件的</p>
<p><strong>用法</strong>: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cat &#123;文件名称&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h3><p>和cat类似,只能展示查看尾部内容(有一些日志文件,只需要看尾部)</p>
<p><strong>作用</strong>: 查看文件尾部</p>
<p><strong>用法</strong>:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">tail [选项] &#123;文件名称&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong>:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-f: 动态查看尾部输出的内容,否则就是静态查看</span><br><span class="line">-n: 指定一共查看尾部多少行 默认是10行</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n 20 /home/docs/sql/bibilili.sql</span><br></pre></td></tr></table></figure>

<h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p>针对tar类型的包,进行打包和解包的操作的.</p>
<p>使用这个命令进行一个解包操作.</p>
<ul>
<li>准备一个可以进行解包操作的文件</li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911115810475.png" alt="image-20230911115810475" style="zoom:50%;" />

<p>&#x2F;home&#x2F;resources&#x2F;mysql-connector-java-8.0.26.tar.gz</p>
<ul>
<li>上传到服务器apache-mave-3.8.8.tar.gz</li>
</ul>
<p>从笔记资料中拿到这个练习的tar包.</p>
<p>在finalshell中使用工具上传.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911120250517.png" alt="image-20230911120250517" style="zoom:50%;" />

<p>点击右上上传按钮</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911120342618.png" alt="image-20230911120342618" style="zoom:50%;" />

<p>利用上述基础命令,检查是否上传成功.</p>
<h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><p><strong>作用</strong>: 将tar压缩包解压到文件夹</p>
<p><strong>用法</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf &#123;tar包&#125; -C &#123;解压目录&#125;</span><br></pre></td></tr></table></figure>

<p>不添加-C 默认解压到当前执行tar命令的所在目录</p>
<p>-x 表示解压</p>
<p>-f 表示对应文件</p>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p><strong>作用</strong>: 将文件夹打包到压缩包</p>
<p><strong>用法</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cf &#123;tar包&#125; &#123;压缩目录&#125;</span><br></pre></td></tr></table></figure>

<p>-c: 压缩一个文件夹到tar包</p>
<p>-f: 对应的压缩文件</p>
<h3 id="wget指令"><a href="#wget指令" class="headerlink" title="wget指令"></a>wget指令</h3><p>作用: 直接将下载资源下载的当前linux系统</p>
<p>用法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget &#123;资源地址&#125;</span><br></pre></td></tr></table></figure>

<p>以redis下载为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/redis-stable.tar.gz</span><br></pre></td></tr></table></figure>

<p>按照redis官方文档 进行redis源码安装.</p>
<h2 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h2><p>linux 操作和使用 绝离不开文本的编辑功能.</p>
<p>在linux中有2种文本编辑器 vi vim 后者是升级版,相对来讲vi 足够使用了 vim多了一些功能,让编辑更方便.</p>
<h3 id="vim的三种状态"><a href="#vim的三种状态" class="headerlink" title="vim的三种状态"></a>vim的三种状态</h3><p>当使用vim编辑一个文档的时候,使用vim命令打开文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim &#123;文件名&#125;</span><br></pre></td></tr></table></figure>

<p>要了解vim打开编辑的三种状态</p>
<ul>
<li>一般模式:</li>
<li>编辑模式:</li>
<li>命令模式:</li>
</ul>
<h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p>每次使用vim打开一个存在的或者不存在的文件,就会进入vim的一般模式.</p>
<p>在一般模式下,不支持直接编辑.支持操作vim的快捷键.</p>
<ul>
<li>dd: 剪切一行到剪切板</li>
<li>[n]dd: 从光标所在行向下剪切n行到剪切板</li>
<li>yy: 复制贯标一行到剪切板 和dd的区别就是不会造成原文本的消失</li>
<li>[n]yy: 从光标所在的行向下赋值n行到剪切板</li>
<li>u: 回退到上一步</li>
<li>p: 粘贴当前剪切板内容都当前光标所在下一行</li>
</ul>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>从一般模式可以进入到编辑模式,一旦进入编辑模式,可以在文本中实现任意字符内容的编写了.</p>
<p>一般模式和编辑模式可以相互切换</p>
<p><strong>一般模式</strong>–&gt;<strong>编辑模式</strong>,直接输入快捷键</p>
<ul>
<li><p>a:当前光标向后一个</p>
</li>
<li><p>A:当前光标调到行末尾</p>
</li>
<li><p><strong>i</strong>: 光标位置不变</p>
</li>
<li><p>I: 和A相反 调到当前行第一个</p>
</li>
<li><p><strong>o</strong>: 向下一行 并且带有回车</p>
</li>
<li><p>O: 和o相反,在当前光标所在的上一行 换行回车</p>
</li>
</ul>
<p>替换编辑</p>
<ul>
<li><p>r: 点击一次r 替换光标所在的文字一次(替换文件中端口号)</p>
</li>
<li><p>R: 点击一次R 直到ESC键退出编辑,一直替换</p>
</li>
</ul>
<p><strong>编辑模式–&gt;一般模式 输入ESC退出</strong></p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911143552542.png" alt="image-20230911143552542" style="zoom:50%;" />

<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>可以在vim编辑器里对文本内容编辑完成之后,之前做一些命令操作,实现功能.</p>
<p>比如 不保存 退出 保存 保存完退出 查看当前文件行数 另存为</p>
<p>进入命令模式的方式: 一般模式下直接输入? : &#x2F; 表示要输入的命令</p>
<p><strong>一般模式–&gt;命令模式</strong></p>
<p>一般模式下直接输入? : &#x2F;</p>
<p>命令:</p>
<p>:w 保存</p>
<p>:q 退出</p>
<p>:wq 保存退出</p>
<p>:q! 编辑后不保存退出</p>
<p>&#x2F;{文本} 搜索</p>
<p>:%s&#x2F;{原文}&#x2F;{替换后文本}&#x2F;g</p>
<p>:w {新的文件名称}</p>
<p><strong>命令模式–&gt;一般模式</strong></p>
<p>输入的命令内容直接全部删除,就回退到了一般模式</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911144747268.png" alt="image-20230911144747268"></p>
<h2 id="安装配置一下linux系统的环境变量java"><a href="#安装配置一下linux系统的环境变量java" class="headerlink" title="安装配置一下linux系统的环境变量java"></a>安装配置一下linux系统的环境变量java</h2><p>在linux系统可以利用上述学习的一些技能或者命令,配置一个java环境.</p>
<p>只需要在环境变量Path中指定java中jdk的bin文件夹就可以了.</p>
<h3 id="jdk安装包上传到虚拟机"><a href="#jdk安装包上传到虚拟机" class="headerlink" title="jdk安装包上传到虚拟机"></a>jdk安装包上传到虚拟机</h3><ul>
<li>参考上面maven上传</li>
<li>上传文件位置确定</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911145257022.png" alt="image-20230911145257022"></p>
<h3 id="解压jdk"><a href="#解压jdk" class="headerlink" title="解压jdk"></a>解压jdk</h3><p>使用tar命令找到这个tar包进行解压</p>
<p>将其解压到&#x2F;home&#x2F;software&#x2F;jdk1.8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf jdk-8u65-linux-x64.tar.gz -C /home/software/</span><br><span class="line">mv /home/software/&#123;jdk文件夹&#125; /home/software/jdk1.8</span><br></pre></td></tr></table></figure>

<h3 id="编辑环境变量"><a href="#编辑环境变量" class="headerlink" title="编辑环境变量"></a>编辑环境变量</h3><p>使用vim编辑器 编辑&#x2F;etc&#x2F;profile 是给当前登录用户临时生效的环境变量配置文件</p>
<p>Path变量中添加一个 &#x2F;home&#x2F;software&#x2F;jdk1.8&#x2F;bin 就能生效当前解压的java环境</p>
<p>在文件中添加如下内容</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/home/software/jdk1.8</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<p>{环境变量}&#x3D;{值}</p>
<p>{环境变量}&#x3D;${环境变量}</p>
<p>{环境变量}&#x3D;{值1}:{值2}</p>
<h3 id="保存退出-生效文件"><a href="#保存退出-生效文件" class="headerlink" title="保存退出 生效文件"></a>保存退出 生效文件</h3><p>在编辑模式 按ESC</p>
<p>在一般模式 输入 :wq</p>
<p>在命令提示符中输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>最后输入命令 确定当前环境中有我们添加的环境变量内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911152424313.png" alt="image-20230911152424313"></p>
<h1 id="docker镜像和容器"><a href="#docker镜像和容器" class="headerlink" title="docker镜像和容器"></a>docker镜像和容器</h1><p>目的:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解docker是什么</li>
<li><input checked="" disabled="" type="checkbox"> 理解docker 镜像和容器的关系</li>
<li><input checked="" disabled="" type="checkbox"> 掌握学习讲解的docker基础命令</li>
<li><input checked="" disabled="" type="checkbox"> 掌握使用docker快速搭建一个mysql容器</li>
</ul>
<h2 id="docker-概括"><a href="#docker-概括" class="headerlink" title="docker 概括"></a>docker 概括</h2><h3 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h3><p>docker官网: <a href="https://www.docker.com/">https://www.docker.com</a></p>
<p>docker官方镜像网站: <a href="https://hub.docker.com/;https://hub-stage.docker.com">https://hub.docker.com/;https://hub-stage.docker.com</a></p>
<p>虚拟化的<strong>容器</strong>技术(vm workstation oracle Virtualbox相同的).可以在宿主机创建大量独立隔离的操作系统,运行不同软件.</p>
<p>通过镜像可以将大量的安装好的,配置好环境的系统内容进行保存,然后通过进行可以快速的启动大量容器,实现快速搭建.</p>
<p>应用场景:</p>
<p>例如: 购物节,或者各种网站活动时,活动期间,企业会大量创建容器,应对高并发. 一个容器就可以理解为一个软件运行在一个服务器.</p>
<p>几秒钟之内 立刻启动上万个容器,运行上万个tomcat进程.</p>
<h2 id="docker安装和启动"><a href="#docker安装和启动" class="headerlink" title="docker安装和启动"></a>docker安装和启动</h2><p>主要针对rockyLinux系统做安装和启动.(下发的OVA导入的virtualbox 不需要安装);</p>
<h3 id="删除旧版本docker"><a href="#删除旧版本docker" class="headerlink" title="删除旧版本docker"></a>删除旧版本docker</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="配置docker镜像仓库"><a href="#配置docker镜像仓库" class="headerlink" title="配置docker镜像仓库"></a>配置docker镜像仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="安装docker引擎"><a href="#安装docker引擎" class="headerlink" title="安装docker引擎"></a>安装docker引擎</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h3 id="启动引擎"><a href="#启动引擎" class="headerlink" title="启动引擎"></a>启动引擎</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="检查安装是否正确"><a href="#检查安装是否正确" class="headerlink" title="检查安装是否正确"></a>检查安装是否正确</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>这个命令在有网络连接,前面docker镜像仓库配置是正确的情况下,可以看到一个有效的结果.</p>
<h3 id="docker的核心概念镜像和容器"><a href="#docker的核心概念镜像和容器" class="headerlink" title="docker的核心概念镜像和容器"></a>docker的核心概念镜像和容器</h3><h3 id="mysql容器启动"><a href="#mysql容器启动" class="headerlink" title="mysql容器启动"></a>mysql容器启动</h3><p>docker能够快速启动和搭建环境.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d  -p 3310:3306 mysql</span><br></pre></td></tr></table></figure>

<p>这个命令启动运行成功后,立刻在系统中会出现一个可以帮助我们完成mysql数据库功能的docker容器进程,外界可以使用数据库的客户端连接这个容器.和单独启动搭建安装一个mysql的软件没有任何区别.</p>
<h3 id="docker的架构"><a href="#docker的架构" class="headerlink" title="docker的架构"></a>docker的架构</h3><ul>
<li>宿主机: docker引擎所在的系统 就是宿主机(当前宿主机就是virtual box里的rockyLinux)</li>
<li>镜像: 本质是一批文件,文件保存了一个系统的环境所有内容.例如,工程师将环境安装好,软件搭建好,可以生成镜像文件images,可以复制传递.里面包含的就是一个完整系统所有环境信息.</li>
<li>镜像仓库: 同一个软件,同一个镜像,具有很多不同的版本,这时候,将镜像名字称为镜像仓库名称,不同的版本称为镜像仓库的tag标签,由这些镜像组成的一个海量的文件库,就是镜像仓库.一般是保存在远程服务器的.</li>
<li>镜像仓库服务器: 保存海量镜像仓库的服务器.<ul>
<li>公开的镜像仓库服务器: hub.docker.com</li>
<li>私有的镜像仓库服务器: 各公司自己搭建</li>
</ul>
</li>
<li>容器: 基于某个镜像,docker启动的一个进程,这个进程里面,包含镜像所有内容的一个独立的系统.</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911160234400.png" alt="image-20230911160234400"></p>
<h2 id="docker命令学习"><a href="#docker命令学习" class="headerlink" title="docker命令学习"></a>docker命令学习</h2><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><ul>
<li>docker命令的结构</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">docker &#123;子命令&#125; [选项] [参数]</span><br></pre></td></tr></table></figure>

<ul>
<li>docker images</li>
</ul>
<p>主要用来查看当前本地镜像有哪些;</p>
<p><img src="D:\IDEA\IdeaProjects\jsd2304-notes\notes\DAY22\images\image-20230911163132406.png" alt="image-20230911163132406"></p>
<p>REPOSITORY: 镜像仓库名称</p>
<p>TAG: 标签一般是版本号 如果是latest对应的是当前仓库最新的版本</p>
<p>IMAGE ID: 镜像的ID</p>
<p>CREATED: 创建时间</p>
<p>SIZE: 大小</p>
<p>可用的选项 </p>
<p>-a: 展示所有镜像信息 </p>
<p>-q: 只显示镜像id(<strong>可以作为一个内嵌的命令给外面包裹的命令传递参数</strong>)</p>
<ul>
<li>docker search</li>
</ul>
<p>我们需要的镜像可以在docker的仓库里进行搜索，也可以使用docker search命令进行搜索。例如需要启动nacos-server进程镜像.</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911163705215.png" alt="image-20230911163705215"></p>
<p>NAME: 镜像仓库名称</p>
<p>DESCRIPTION: 描述</p>
<p>STARS: 星级 星级越高,热度和受欢迎度越高.</p>
<p>OFFICIAL: [OK] 说明是官方镜像,如果没有就不是官方</p>
<p>AUTOMATED: 自动化 是否支持.</p>
<p>如果想要更清楚的知道如何使用这个镜像,最好到官方仓库查看.</p>
<p>一般官方镜像都会提供运行命令.</p>
<ul>
<li>docker pull</li>
</ul>
<p>当我们需要用到某个镜像的时候，可以利用pull命令将镜像从远程仓库下载到本地。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull &#123;仓库名&#125;:&#123;tag&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/linux.png" style="zoom:50%;" />

<p>一个镜像的tag的值可以是默认的,如果不给,就是latest</p>
<ul>
<li>docker rmi</li>
</ul>
<p>当下载的镜像越来越多，不需要用到镜像时，可以执行rmi删除镜像命令。</p>
<p>命令后面可以添加镜像的id值 可以添加多个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi id1 id2 id3</span><br></pre></td></tr></table></figure>

<p>如果想要将当前宿主机中的镜像清空.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -aq)</span><br></pre></td></tr></table></figure>

<p>这是一个docker支持的内部嵌套的执行 将$()中的命令执行的返回结果当做外部命令的参数使用.</p>
<p>如果直接删除,某些镜像在绑定容器使用,导致镜像无法删除掉,可以添加选项</p>
<p>-f 强制删除.</p>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>我们可以利用下载好的镜像,启动各种各样要求 配置 参数的容器.</p>
<ul>
<li>docker run</li>
</ul>
<p>我们可以利用docker run的命令使用我们下载好的镜像，来创建和启动容器。前面我们介绍过，镜像好似模具，而容器就是利用这模具创建的实例。一个镜像可以创建运行多个容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name abcd -e JAVA_HOME=/home/abc -p 8000:3306 mysql</span><br></pre></td></tr></table></figure>

<p>-d : 容器启动后 在后台运行,如果不添加这个选项,运行和启动的容器 就会直接进入容器.直到容器停止,或者手动退出.</p>
<p>–name: 给容器启动时,添加一个容器名称,容器不能重名</p>
<p>-e: 给容器启动的时候,容器内部的环境变量 提供你想要指定变量名</p>
<p>-p: 指定绑定宿主机端口的选项.可以通过多次使用-p绑定多个端口</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-p &#123;宿主机端口&#125;:&#123;容器内部系统端口&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>docker ps</li>
</ul>
<p>当容器启动后，我们在宿主机可以通过ps命令查看容器相关的信息。</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230911170900287.png" alt="image-20230911170900287"></p>
<p>CONTAINER ID: 容器id 全部id没有展示只展示前12位</p>
<p>IMAGE: 启动容器镜像仓库名称</p>
<p>COMMAND: 容器内部正在运行的脚本,正在运行的一个进程</p>
<p>CREATED: 创建时间</p>
<p>STATUS: 容器运行状态 目前都是Up 还有Exited</p>
<p>PORTS: 绑定端口信息</p>
<p>NAMES: 容器名称</p>
<p>查询docker ps的选项</p>
<p>-a: 显示所有容器,如果不添加,显示的容器只是运行Up状态的.</p>
<p>-l: 显示最近启动或者创建的容器</p>
<p>-n&#x3D;{数字}: 显示自定义个数容器</p>
<p>-q: 只显示容器的id</p>
<ul>
<li>docker rm</li>
</ul>
<p>使用镜像创建的容器，可以使用rm进行删除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm &#123;容器id&#125; &#123;容器id&#125; &#123;容器id&#125;</span><br></pre></td></tr></table></figure>

<p>删除所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure>



<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">docker run --name abc -e MYSQL_ROOT_PASSWORD=123456 -d -p 3399:3306 mysql</span><br></pre></td></tr></table></figure>

<h3 id="启动我需要的其它容器"><a href="#启动我需要的其它容器" class="headerlink" title="启动我需要的其它容器"></a>启动我需要的其它容器</h3><p>目标: 启动一个可以被外界访问的nacos服务端</p>
<p>hub.docker.com 搜索nacos&#x2F;nacos-server里面也会有和mysql一样的描述</p>
<p>包括redis</p>
]]></content>
      <categories>
        <category>常用工具和框架</category>
      </categories>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2023/08/20/AOP/</url>
    <content><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP：面向切面的编程</p>
<p>AOP是由AspectJ提供的技术，Spring框架很好的支持了AOP。</p>
<p>AOP主要解决了横切关注的问题（若干个不同的方法都需要解决的问题），典型的应用场景有：错误的处理、事务管理、安全检查、日志等等。</p>
<p>在Spring Boot项目中，需要添加<code>spring-boot-starter-aop</code>依赖，才可以进行AOP编程。</p>
<p>演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.tmall.admin.mall.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计各Service方法的执行耗时的切面类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> java@tedu.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 标记此类是一个切面类，Spring AOP会将此类编织到匹配的连接点的执行过程中</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 标记此类是一个组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接点（JoinPoint）：程序执行过程中的某个节点，可能是方法的调用，或抛出异常</span></span><br><span class="line">    <span class="comment">// 切入点（Point Cut）：是匹配1个或多个连接点的表达式</span></span><br><span class="line">    <span class="comment">// 通知（Advice）：包含了切入点表达式与执行的方法</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Advice的种类（使用不同Advice时，方法的参数列表将不同）：</span></span><br><span class="line">    <span class="comment">// -- @Before：前置，你的代码将在连接点【之前】执行</span></span><br><span class="line">    <span class="comment">// -- @After：后置，你的代码将在连接点【之后】执行</span></span><br><span class="line">    <span class="comment">// -- @AfterReturning：返回之后，你的代码将在连接点【成功返回之后】执行</span></span><br><span class="line">    <span class="comment">// -- @AfterThrowing：抛出异常之后，你的代码将在连接点【抛出异常之后】执行</span></span><br><span class="line">    <span class="comment">// -- @Around：环绕，你的代码可以在连接点【之前和之后】执行</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 各Advice的执行节点大致是：</span></span><br><span class="line">    <span class="comment">// @Around：开始</span></span><br><span class="line">    <span class="comment">// try &#123;</span></span><br><span class="line">    <span class="comment">//      @Before</span></span><br><span class="line">    <span class="comment">//      连接点</span></span><br><span class="line">    <span class="comment">//      @AfterReturning</span></span><br><span class="line">    <span class="comment">// &#125; catch (Throwable e) &#123;</span></span><br><span class="line">    <span class="comment">//      @AfterThrowing</span></span><br><span class="line">    <span class="comment">// &#125; finally &#123;</span></span><br><span class="line">    <span class="comment">//      @After</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// @Around：结束</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 关于切入点表达式：</span></span><br><span class="line">    <span class="comment">// -- 完整的切入点表达式格式为：[修饰符] 返回值类型 [包名]类名.方法名(参数列表) [异常]</span></span><br><span class="line">    <span class="comment">// -- 可以使用1个星号作为通配符，用于匹配任意内容，只会且必须匹配1次</span></span><br><span class="line">    <span class="comment">// -- 可以使用2个连接的小数点作为通配符，可以匹配若干次（0~n次），只能用于包名和参数列表</span></span><br><span class="line">    <span class="comment">//                 ↓ 返回值类型</span></span><br><span class="line">    <span class="comment">//                   ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 包名</span></span><br><span class="line">    <span class="comment">//                                                    ↓ 类型名</span></span><br><span class="line">    <span class="comment">//                                                      ↓ 方法名</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* cn.tedu.tmall.admin.mall.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="comment">//     ↓↓↓↓↓↓ 方法的返回值类型必须是Object【适用于@Around】</span></span><br><span class="line">    <span class="comment">//            ↓↓↓↓↓ 切面方法的名称可以完全自定义</span></span><br><span class="line">    <span class="comment">//                  ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 处理连接点的对象，方法参数必须是此类型【适用于@Around】</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">timer</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取连接点的相关信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pjp.getTarget().getClass().getName(); <span class="comment">// 获取当前连接点所归属的对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pjp.getSignature().getName(); <span class="comment">// 获取当前连接点方法的名称</span></span><br><span class="line">        Object[] args = pjp.getArgs(); <span class="comment">// 获取当前连接点方法执行的参数列表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;className = &quot;</span> + className);</span><br><span class="line">        System.out.println(<span class="string">&quot;methodName = &quot;</span> + methodName);</span><br><span class="line">        System.out.println(<span class="string">&quot;args = &quot;</span> + Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行连接点</span></span><br><span class="line">        <span class="comment">// 注意-1：调用连接点时，必须获取返回值，且作为当前切面的返回值</span></span><br><span class="line">        <span class="comment">// 注意-2：调用连接点时，必须将异常抛出（或者，使用try...catch处理时，在catch代码块再次抛出异常）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (end - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring相关</category>
      </categories>
  </entry>
  <entry>
    <title>Elasticsearch</title>
    <url>/2023/08/20/Elasticsearch/</url>
    <content><![CDATA[<h1 id="关于Elasticsearch"><a href="#关于Elasticsearch" class="headerlink" title="关于Elasticsearch"></a>关于Elasticsearch</h1><p>Elaticsearch是专门用于解决搜索问题的NoSQL的文档数据库。</p>
<p>无论使用哪种操作系统，只需要下载elasticsearch的压缩包并解压即可使用，需要注意，elasticsearch文件夹的各层级的父级文件夹的名称中不允许包含非ASCII码字符和空格！例如放在D盘根目录下：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810103020943.png" alt="image-20230810103020943"></p>
<p>执行<code>bin</code>目录下的<code>elasticsearch</code>即可启用Elasticsearch服务：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810103215524.png" alt="image-20230810103215524"></p>
<p>启动成功后，效果大致如下：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810103356288.png" alt="image-20230810103356288"></p>
<p><strong>注意：</strong>在使用Elasticsearch的过程中，以上窗口不可关闭！</p>
<p>当启动成功后，你可以通过浏览器访问 <a href="http://localhost:9200，页面显示内容如下：">http://localhost:9200，页面显示内容如下：</a></p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810103913516.png" alt="image-20230810103913516"></p>
<p>elasticsearch提供了一套基于RESTful的访问，你可以使用任何一种可以提交REST请求的工具来访问elasticsearch及其中的数据，例如常见的测试工具PostMan等。</p>
<p>或者，你也可以在IntelliJ IDEA中，使用HTTP Request进行访问：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810104355105.png" alt="image-20230810104355105"></p>
<p>在HTTP Request文件中编写需要提交的请求，然后，点击左侧的运行图标即可发起请求</p>
<p><img src="D:\IDEA\IdeaProjects\jsd2304-tmall-server-teacher\doc\note\images\image-20230810104550441.png" alt="image-20230810104550441"></p>
<h1 id="使用elasticsearch分词"><a href="#使用elasticsearch分词" class="headerlink" title="使用elasticsearch分词"></a>使用elasticsearch分词</h1><p>Elasticsearch之所以能够高效处理搜索，是因为它会将你的数据进行“分词”处理，即将一段文本拆成若干个文本，在执行搜索时，会尝试检查是否匹配“拆”出来的某个文本。</p>
<p>向 <a href="http://localhost:9200/_analyze">http://localhost:9200/_analyze</a> 提交请求即可分词，并且，请求中必须包含请求参数，参数名称固定为<code>text</code>，整个请求的格式大致如下：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810113711741.png" alt="image-20230810113711741"></p>
<p>提示：在同一个<code>.http</code>文件中，可以编写多个请求，但是，后续的请求的代码必须使用 <code>###</code> 和前序的请求分开，不能只使用1个 <code>#</code>！</p>
<p>你也可以尝试对中文的句子进行分词，会发现，在默认情况下，Elasticsearch只能将中文中的每个字拆出来，并不能正确的处理各个词语！</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 测试分词 -- 中文</span><br><span class="line">GET http://localhost:9200/_analyze</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;很高兴认识你！&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在Elasticsearch中添加新的分词插件来解决以上问题，经典的中文分词插件就是ik分词器。</p>
<p>所有插件都应该放在Elasticsearch下的plugin文件夹下：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810114606110.png" alt="image-20230810114606110"></p>
<p>你需要将下载得到的ik分词器的压缩包解压出来，将解压得到的文件夹放在<code>plugins</code>文件夹下，而ik分词器的文件夹名称就叫<code>ik</code>即可：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810114744905.png" alt="image-20230810114744905"></p>
<p><strong>注意：</strong>完成后，需要重启Elasticsearch（关了再打开）才可以应用新添加的分词器！</p>
<p>接下来，你就可以使用IK分词器对中文的句子进行分词！你需要在请求参数中通过<code>analyzer</code>属性来指定分词器，取值可以是IK分词器提供的<code>ik_smart</code>或<code>ik_max_word</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 测试分词 -- 中文 -- ik_smart</span><br><span class="line">GET http://localhost:9200/_analyze</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;很高兴认识你！&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 测试分词 -- 中文 -- ik_max_word</span><br><span class="line">GET http://localhost:9200/_analyze</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;很高兴认识你！&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用IK分词器时，可以自造词！例如：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230810140842583.png" alt="image-20230810140842583"></p>
<h1 id="Elasticsearch文档数据库的相关概念"><a href="#Elasticsearch文档数据库的相关概念" class="headerlink" title="Elasticsearch文档数据库的相关概念"></a>Elasticsearch文档数据库的相关概念</h1><p><strong>索引（index &#x2F; indices）</strong></p>
<ul>
<li>相当于MySQL中的Database</li>
</ul>
<p><strong>类型（type &#x2F; types）</strong></p>
<ul>
<li>相当于MySQL中的Table，可以自行创建“类型”，或者，如果不关心“类型”，使用 <code>_doc</code> 表示类型名</li>
<li>ES本身并不注重“类型”的概念，甚至在较高版本（8.x或以上）基本已废弃此概念</li>
</ul>
<p><strong>文档（document &#x2F; documents）</strong></p>
<ul>
<li>相当于MySQL中各数据表中一行行的数据</li>
<li>在ES中每个数据都是由JSON格式组织的</li>
</ul>
<p><strong>字段（field &#x2F; fields）</strong></p>
<ul>
<li>相当于MySQL中的Column</li>
</ul>
<h1 id="基于RESTful访问Elasticsearch"><a href="#基于RESTful访问Elasticsearch" class="headerlink" title="基于RESTful访问Elasticsearch"></a>基于RESTful访问Elasticsearch</h1><h2 id="操作汇总"><a href="#操作汇总" class="headerlink" title="操作汇总"></a>操作汇总</h2><h2 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h2><p><strong>添加文档（使用ES随机生成的ID值）</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:9200/&#123;索引名&#125;/&#123;类型名&#125;</span><br></pre></td></tr></table></figure>

<p>提示：添加文档时，如果索引不存在，会自动创建索引，如果类型不存在，会自动创建类型！</p>
<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 添加文档</span><br><span class="line">POST http://localhost:9200/index_crud/_doc</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 998,</span><br><span class="line">  &quot;title&quot;: &quot;2023新茶上市，赔本大甩卖&quot;,</span><br><span class="line">  &quot;sort&quot;: 188</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加文档（自行指定ID值）</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT http://localhost:9200/&#123;索引名&#125;/&#123;类型名&#125;/&#123;文档ID&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 添加文档（自行指定ID值）</span><br><span class="line">PUT http://localhost:9200/index_crud/_doc/Tea9527</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 999,</span><br><span class="line">  &quot;title&quot;: &quot;2023老茶上市，卖得也相当不错&quot;,</span><br><span class="line">  &quot;sort&quot;: 199</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>根据ID删除文档</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE http://localhost:9200/&#123;索引名&#125;/&#123;类型名&#125;/&#123;文档ID&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 根据ID删除文档</span><br><span class="line">DELETE http://localhost:9200/index_crud/_doc/Tea9527</span><br></pre></td></tr></table></figure>

<p>提示：如果尝试删除的文档不存在，将响应<code>404</code>错误！</p>
<p><strong>删除索引</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE http://localhost:9200/&#123;索引名&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 删除索引</span><br><span class="line">DELETE http://localhost:9200/index_crud</span><br></pre></td></tr></table></figure>

<p>提示：如果尝试删除的索引不存在，将响应<code>404</code>错误！</p>
<h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p><strong>修改文档（更新整篇文档）</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT http://localhost:9200/&#123;索引名&#125;/&#123;类型名&#125;/&#123;文档ID&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 修改文档（更新整篇文档）</span><br><span class="line">PUT http://localhost:9200/index_crud/_doc/Tea9527</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 999,</span><br><span class="line">  &quot;title&quot;: &quot;2023老茶上市，卖得也相当不错&quot;,</span><br><span class="line">  &quot;sort&quot;: 199,</span><br><span class="line">  &quot;description&quot;: &quot;这个老茶味道很好，强烈推荐！&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：以上做法将使用请求参数替换原有的整篇文档！</p>
<p><strong>修改文档（局部修改）</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:9200/&#123;索引名&#125;/&#123;类型名&#125;/&#123;文档ID&#125;/_update</span><br></pre></td></tr></table></figure>

<p>请求参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        需要更新的数据的参数</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 修改文档（局部修改）</span><br><span class="line">POST http://localhost:9200/index_crud/_doc/Tea9527/_update</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;sort&quot;: 189,</span><br><span class="line">    &quot;description&quot;: &quot;老茶和新茶味道还是挺不一样，要不，买个试试？&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果请求参数中包含新的属性（原文档中没有的属性），也会更新成功，且在文档中新增新的属性！</p>
<h2 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h2><p><strong>查看某个索引中的所有文档</strong></p>
<p>请求格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/&#123;索引名&#125;/_search</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 查看某个索引中的所有文档</span><br><span class="line">GET http://localhost:9200/index_crud/_search</span><br></pre></td></tr></table></figure>

<p><strong>根据ID访问文档</strong></p>
<p>请求格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/&#123;索引名&#125;/&#123;类型名&#125;/&#123;文档ID&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 根据ID访问文档</span><br><span class="line">GET http://localhost:9200/index_crud/_doc/yjEl3okBucTgSd_ILGK2</span><br></pre></td></tr></table></figure>

<h1 id="Elasticsearch中的数据类型"><a href="#Elasticsearch中的数据类型" class="headerlink" title="Elasticsearch中的数据类型"></a>Elasticsearch中的数据类型</h1><p>在Elasticsearch中，各字段的值也是有数据类型的，大致为：</p>
<ul>
<li>字符串类型：<code>text</code>、<code>keyword</code><ul>
<li><code>text</code>类型在被处理时，默认会被分词<ul>
<li>默认</li>
</ul>
</li>
<li><code>keyword</code>类型在被处理时，默认不会被分词</li>
</ul>
</li>
<li>数值类型：<code>byte</code>、<code>short</code>、<code>integer</code>、<code>long</code>、<code>float</code>、<code>double</code>等</li>
<li>布尔类型：<code>boolean</code></li>
<li>日期类型：<code>date</code></li>
</ul>
<p>例如，准备一些测试数据：</p>
<table>
<thead>
<tr>
<th>ID（id）</th>
<th>标题（title）</th>
<th>简介（description）</th>
<th>排序序号（sort）</th>
<th>售价（price）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>散装龙井</td>
<td>好喝又实惠</td>
<td>160</td>
<td>300</td>
</tr>
<tr>
<td>2</td>
<td>大红袍大礼包</td>
<td>性价比之王</td>
<td>190</td>
<td>688</td>
</tr>
<tr>
<td>3</td>
<td>龙井礼盒</td>
<td>送礼必备</td>
<td>130</td>
<td>888</td>
</tr>
<tr>
<td>4</td>
<td>精装陈年老普洱</td>
<td>收藏珍品</td>
<td>150</td>
<td>988</td>
</tr>
<tr>
<td>5</td>
<td>精装铁观音大礼包</td>
<td>家中常备</td>
<td>160</td>
<td>700</td>
</tr>
</tbody></table>
<p>在使用Elasticsearch时，应该先手动创建索引，并确定此索引中的文档有哪些字段，及字段的数据类型！</p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 自定义索引及其文档的属性和数据类型</span><br><span class="line">PUT http://localhost:9200/&#123;索引名&#125;</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;mappings&quot;: &#123;</span><br><span class="line">		&quot;properties&quot;: &#123;</span><br><span class="line">			&quot;&#123;字段名1&#125;&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;&#123;字段类型1&#125;&quot;,</span><br><span class="line">				&quot;analyzer&quot;: &quot;&#123;分词器名称，仅用于text类型的字段&#125;&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;&#123;字段名2&#125;&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;&#123;字段类型2&#125;&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			... ...</span><br><span class="line">			&quot;&#123;字段名n&#125;&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;&#123;字段类型n&#125;&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 自定义索引及其文档的属性和数据类型</span><br><span class="line">PUT http://localhost:9200/index_search</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;description&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;sort&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入测试数据示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 添加文档--测试数据1</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/1</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;title&quot;: &quot;散装龙井&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;好喝又实惠&quot;,</span><br><span class="line">  &quot;sort&quot;: 160,</span><br><span class="line">  &quot;price&quot;: 300</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据2</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/2</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 2,</span><br><span class="line">  &quot;title&quot;: &quot;大红袍大礼包&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;性价比之王&quot;,</span><br><span class="line">  &quot;sort&quot;: 190,</span><br><span class="line">  &quot;price&quot;: 688</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据3</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/3</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 3,</span><br><span class="line">  &quot;title&quot;: &quot;龙井礼盒&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;送礼必备&quot;,</span><br><span class="line">  &quot;sort&quot;: 130,</span><br><span class="line">  &quot;price&quot;: 888</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据4</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/4</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 4,</span><br><span class="line">  &quot;title&quot;: &quot;精装陈年老普洱&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;收藏珍品&quot;,</span><br><span class="line">  &quot;sort&quot;: 150,</span><br><span class="line">  &quot;price&quot;: 988</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据5</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/5</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 5,</span><br><span class="line">  &quot;title&quot;: &quot;精装铁观音大礼包&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;家中常备&quot;,</span><br><span class="line">  &quot;sort&quot;: 160,</span><br><span class="line">  &quot;price&quot;: 700</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p><strong>简单的搜索</strong></p>
<p>请求格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/&#123;索引名&#125;/_search?q=&#123;字段名:查询关键字&#125;</span><br></pre></td></tr></table></figure>

<p>请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 根据关键字执行简单的搜索</span><br><span class="line">GET http://localhost:9200/index_search/_search?q=title:龙井</span><br></pre></td></tr></table></figure>

<p><strong>高级搜索</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 添加文档--测试数据1</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/1</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;title&quot;: &quot;散装龙井&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;好喝又实惠&quot;,</span><br><span class="line">  &quot;sort&quot;: 160,</span><br><span class="line">  &quot;price&quot;: 300</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据2</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/2</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 2,</span><br><span class="line">  &quot;title&quot;: &quot;大红袍大礼包&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;性价比之王&quot;,</span><br><span class="line">  &quot;sort&quot;: 190,</span><br><span class="line">  &quot;price&quot;: 688</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据3</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/3</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 3,</span><br><span class="line">  &quot;title&quot;: &quot;龙井礼盒&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;送礼必备&quot;,</span><br><span class="line">  &quot;sort&quot;: 130,</span><br><span class="line">  &quot;price&quot;: 888</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据4</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/4</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 4,</span><br><span class="line">  &quot;title&quot;: &quot;精装陈年老普洱&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;收藏珍品&quot;,</span><br><span class="line">  &quot;sort&quot;: 150,</span><br><span class="line">  &quot;price&quot;: 988</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 添加文档--测试数据5</span><br><span class="line">PUT http://localhost:9200/index_search/_doc/5</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 5,</span><br><span class="line">  &quot;title&quot;: &quot;精装铁观音大礼包&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;家中常备&quot;,</span><br><span class="line">  &quot;sort&quot;: 160,</span><br><span class="line">  &quot;price&quot;: 700</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 删除索引</span><br><span class="line">DELETE http://localhost:9200/index_search</span><br><span class="line"></span><br><span class="line">### 自定义索引及其文档的属性和数据类型</span><br><span class="line">PUT http://localhost:9200/index_search</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;description&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;sort&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 查看某个索引中的基本信息</span><br><span class="line">GET http://localhost:9200/index_search</span><br><span class="line"></span><br><span class="line">### 查看某个索引中的所有文档</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line"></span><br><span class="line">### 简单搜索：根据关键字执行简单的搜索：搜索title中包含“龙井”的数据</span><br><span class="line">GET http://localhost:9200/index_search/_search?q=title:龙井</span><br><span class="line"></span><br><span class="line">### 简单搜索：根据关键字执行简单的搜索：搜索title中包含“精装”的数据，注意，包含“散装”或其它“?装”的数据也会出现在结果中</span><br><span class="line">GET http://localhost:9200/index_search/_search?q=title:精装</span><br><span class="line"></span><br><span class="line">### 简单搜索：根据关键字执行简单的搜索：搜索description中包含“收藏珍品”的数据</span><br><span class="line">GET http://localhost:9200/index_search/_search?q=description:珍品</span><br><span class="line"></span><br><span class="line">### 高级搜索：自定义query，在query属性下配置match属性，在match属性下再配置搜索的字段名与关键字</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;龙井&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 高级搜索：多条件搜索：自定义query，在query属性下配置bool属性，在bool属性下再配置must，must的值是数组，数组元素就是匹配规则，must下的多个规则必须同时匹配才能被搜索到</span><br><span class="line">### 除了must以外，还可以是should，should只需要匹配其中任意1个条件即可</span><br><span class="line">### 另外，还可以是must_not，即不允许是某种规则</span><br><span class="line">### must &gt;&gt;&gt; AND</span><br><span class="line">### should &gt;&gt;&gt; OR</span><br><span class="line">### must_not &gt;&gt;&gt; !=</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;龙井&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;送礼必备&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 高级搜索：查询指定字段的数据，在query同级配置_source，此属性的值是数组，用于指定字段列表</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;: [</span><br><span class="line">    &quot;id&quot;,</span><br><span class="line">    &quot;title&quot;,</span><br><span class="line">    &quot;price&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 高级搜索：指定排序，在query同级配置sort属性，在sort属性中配置排序规则，默认根据字段值升序排列，也可以配置order属性来指定规则，取值为desc时为降序</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;sort&quot;: &#123;&#125;,</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 高级搜索：分页搜索，在query同级配置from和size属性</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;from&quot;: 1,</span><br><span class="line">  &quot;size&quot;: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 高级搜索：高亮显示，在query同级配置highlight属性进行配置，在highlight中配置fields属性，可以指定对应的字段</span><br><span class="line">### 执行搜索后，匹配的结果中会出现同级的highlight数据，其中搜索的关键字默认会被&lt;em&gt;标签框住，后续在客户端拿到此结果后可以对&lt;em&gt;标签设计CSS样式</span><br><span class="line">### 或者，在配置高亮搜索时，还可以在highlight标签下配置pre_tags和post_tags属性，以替换&lt;em&gt;和&lt;/em&gt;标签</span><br><span class="line">GET http://localhost:9200/index_search/_search</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;精装&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;pre_tags&quot;: &quot;&lt;font style=&#x27;color: red;&#x27;&gt;&quot;,</span><br><span class="line">    &quot;post_tags&quot;: &quot;&lt;/font&gt;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Spring-Boot的Elasticsearch编程"><a href="#基于Spring-Boot的Elasticsearch编程" class="headerlink" title="基于Spring Boot的Elasticsearch编程"></a>基于Spring Boot的Elasticsearch编程</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在Spring Boot中，实现Elasticsearch编程需要添加依赖：<code>spring-boot-starter-data-elasticsearch</code></p>
<h2 id="定义文档数据的Java类"><a href="#定义文档数据的Java类" class="headerlink" title="定义文档数据的Java类"></a>定义文档数据的Java类</h2><p>注意：与ES中的文档对应的Java类，并不需要与实体类、用于Redis的相关类保持一致！</p>
<p>使用ES时的Java类可以完全自由设计，只需要包含显示在“搜索结果中的属性（最终显示在客户端界面中的属性）”及“执行搜索时需要匹配的属性”即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsSearchVO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String brief;</span><br><span class="line">    <span class="keyword">private</span> String coverUrl;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal salePrice;</span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="keyword">private</span> Integer isRecommend;</span><br><span class="line">    <span class="keyword">private</span> Integer salesCount;</span><br><span class="line">    <span class="keyword">private</span> Integer commentCount;</span><br><span class="line">    <span class="keyword">private</span> Integer positiveCommentCount;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime gmtCreate;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime gmtModified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="编写数据访问接口"><a href="#编写数据访问接口" class="headerlink" title="编写数据访问接口"></a>编写数据访问接口</h2><p>在Spring Boot项目中添加了Elasticsearch编程的依赖项后，只需要自定义接口，继承自框架中的<code>Repository</code>接口即可表示自定义接口是用于访问数据的，<code>Repository</code>接口需要指定2个泛型，分别是你要操作的数据的类型，和此数据在ES中的ID的类型。</p>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis Plus</title>
    <url>/2023/08/05/MyBatis-Plus/</url>
    <content><![CDATA[<h1 id="MyBatis-Plus简介"><a href="#MyBatis-Plus简介" class="headerlink" title="MyBatis Plus简介"></a>MyBatis Plus简介</h1><p>MyBatis Plus是一款由国人开发的基于MyBatis的无侵入性的框架,<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h1 id="如何使用MyBatis-Plus"><a href="#如何使用MyBatis-Plus" class="headerlink" title="如何使用MyBatis Plus"></a>如何使用MyBatis Plus</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Mybatis Plus整合Spring Boot的依赖项 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">          &lt;mybatis-plus-spring-boot.version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/mybatis-plus-spring-boot.version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="新建Mapper并继承BaseMapper"><a href="#新建Mapper并继承BaseMapper" class="headerlink" title="新建Mapper并继承BaseMapper&lt;T&gt;"></a>新建Mapper并继承BaseMapper&lt;T&gt;</h2><p>在Spring Boot中，在已经添加MyBatis编程相关的依赖项后，补充添加<code>mybatis-plus-boot-starter</code>即可在项目中使用MyBatis Plus。</p>
<p>就像使用MyBatis那样，你需要先准备一个配置类，通过<code>@MapperScan</code>来指定Mapper接口的包，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.tedu.tmall.admin.mall.dao.persist.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，以对应的包下创建Mapper接口文件，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用了MyBatis Plus后，你应该让自己的Mapper接口继承自MyBatis Plus提供的<code>BaseMapper</code>接口，关于<code>BaseMapper</code>接口：</p>
<p>当自定义的Mapper接口继承自<code>BaseMapper</code>后，可以直接使用以上所有方法实现数据访问！</p>
<p>注意：使用<code>BaseMapper</code>时，需要指定其声明的泛型类型，此类型就是当前你需要访问的数据表对应的实体类型！</p>
<p>所以，还需要自行创建数据表对应的实体类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类：商品-类别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> java@tedu.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类别名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父级类别ID，如果无父级，则为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long parentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度，最顶级类别的深度为1，次级为2，以此类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关键词列表，各关键词使用英文的逗号分隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序序号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图标图片的URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用，1=启用，0=未启用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer enable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为父级（是否包含子级），1=是父级，0=不是父级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer isParent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否显示在导航栏中，1=启用，0=未启用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDisplay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime gmtCreate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据最后修改时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime gmtModified;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备好实体类后，使得自定义的Mapper接口继承自<code>BaseMapper</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当使用<code>BaseMapper</code>时传入了实体类型后，MyBatis Plus会根据实体类的名称得到数据表名称，例如实体类名为<code>Category</code>，则MyBatis Plus认为对应的数据表名称就是<code>category</code>，如果需要自行指定数据表名称，需要在实体类上添加<code>@TableName</code>注解进行配置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;mall_category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在插入数据时，MyBatis Plus有自己的ID编号规则，并不是从1开始自动编号的，如果需要使用自动编号的ID，需要在主键对应的属性上配置<code>@TableId</code>注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;mall_category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span> <span class="comment">// 自动编号，步长为1</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过以上配置后，新插入的数据会在现有的最大ID值基础上自增1，得到新的ID值！</p>
<p>注意：如果插入数据的表的主键是自动编号的，当成功插入数据后，MyBatis Plus会获取新数据的自动编号ID值，并存入到参数对象中与主键对应的属性（通常是<code>id</code>属性）上，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();</span><br><span class="line">    category.setName(<span class="string">&quot;测试的类别的名称&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入数据之前，参数：&quot;</span> + category);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> mapper.insert(category);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + rows);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入数据之后，参数：&quot;</span> + category); <span class="comment">// 参数的id是有值的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis Plus提供的许多方法都可以使用<code>Wrapper</code>类型的参数，其简单使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// eq &gt;&gt;&gt; equals</span></span><br><span class="line">    <span class="comment">// ne &gt;&gt;&gt; not equals</span></span><br><span class="line">    <span class="comment">// lt &gt;&gt;&gt; less than</span></span><br><span class="line">    <span class="comment">// gt &gt;&gt;&gt; greater than</span></span><br><span class="line">    QueryWrapper&lt;Category&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lt(<span class="string">&quot;id&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> mapper.delete(wrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>QueryWrapper</code>时，可以用于指定条件的方法都来自其父类<code>AbstractWrapper</code></p>
<p>如果需要自定义查询，应该：</p>
<ul>
<li>创建所需的VO类</li>
<li>在Mapper接口中声明抽象方法</li>
<li>在XML文件中配置抽象方法映射的SQL语句</li>
<li>在配置文件中指定XML文件的位置（一次性配置）</li>
</ul>
<p>注意：如果XML文件在<code>src/main/resources</code>下名为<code>mapper</code>的文件夹下，并不需要在配置文件中指定XML文件的位置，如果使用的文件夹的名称不是<code>mapper</code>（例如使用<code>mappers</code>），则必须在配置文件中使用<code>mybatis-plus.mapper-locations</code>属性进行配置，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mappers/*.xml</span></span><br></pre></td></tr></table></figure>

<h1 id="使用MyBatis-Plus处理数据的创建时间和最后修改时间"><a href="#使用MyBatis-Plus处理数据的创建时间和最后修改时间" class="headerlink" title="使用MyBatis Plus处理数据的创建时间和最后修改时间"></a>使用MyBatis Plus处理数据的创建时间和最后修改时间</h1><p>MyBatis Plus提供了<code>MetaObjectHandler</code>接口，允许自定义组件类实现此接口，并重写方法，以决定自动处理数据的创建时间和最后修改时间！</p>
<p>可以自行创建此组件类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于MyBatis Plus的自动填充时间的处理器类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> java@tedu.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据创建时间的属性名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FIELD_CREATE_TIME</span> <span class="operator">=</span> <span class="string">&quot;gmtCreate&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据最后修改时间的属性名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FIELD_UPDATE_TIME</span> <span class="operator">=</span> <span class="string">&quot;gmtModified&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeMetaObjectHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建MyBatis Plus的自动填充数据的处理器对象：TimeMetaObjectHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(FIELD_CREATE_TIME, now, metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(FIELD_UPDATE_TIME, now, metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(FIELD_UPDATE_TIME, now, metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，需要在实体类中需要自动填充时间的属性上添加注解进行配置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据创建时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime gmtCreate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据最后修改时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime gmtModified;</span><br></pre></td></tr></table></figure>

<h1 id="MyBatis-Plus的分页插件"><a href="#MyBatis-Plus的分页插件" class="headerlink" title="MyBatis Plus的分页插件"></a>MyBatis Plus的分页插件</h1><p>MyBatis Plus自带分页插件,只需要简单的配置即可实现分页功能.</p>
<h2 id="新建配置类-配置分页插件"><a href="#新建配置类-配置分页插件" class="headerlink" title="新建配置类,配置分页插件"></a>新建配置类,配置分页插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mybatisplus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">config</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">       MybatisPlusInterceptor interceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">       interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">       <span class="keyword">return</span> interceptor;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>Page<User> page&#x3D;new Page&lt;&gt;(1,3);两个参数分别为(当前查询页数,每页查询条数)</p>
<p>userMapper.selectPage(page,null);因为要查询所有信息,所以第二个参数Wrapper为’null’</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">       Page&lt;User&gt; page=<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">       userMapper.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">       System.out.println(page.getRecords());</span><br><span class="line">       System.out.println(page.getCurrent());</span><br><span class="line">       System.out.println(page.getTotal());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">       user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">       user.setAge(<span class="string">&quot;18&quot;</span>);</span><br><span class="line">       userMapper.insert(user);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">       wrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> userMapper.delete(wrapper);</span><br><span class="line">        System.out.println(delete);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;50&quot;</span>).or().like(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setUserName(<span class="string">&quot;guigu&quot;</span>);</span><br><span class="line">       user.setPassword(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line">       userMapper.update(user,queryWrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询内容并按’age’降序排列,如果’age’相同,按’id’升序排列.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   QueryWrapper&lt;User&gt; wrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">   wrapper.orderByDesc(<span class="string">&quot;age&quot;</span>).orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       <span class="keyword">for</span> (User user: list)&#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="带有lambda中的数据条件优先执行"><a href="#带有lambda中的数据条件优先执行" class="headerlink" title="带有lambda中的数据条件优先执行"></a>带有lambda中的数据条件优先执行</h2><p>and(i-&gt;i.le(“age”,”20”).like(“email”,”6”))条件会先执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.like(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;guigu&quot;</span>).and(i-&gt;i.le(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>).like(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;6&quot;</span>));</span><br><span class="line">       User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setUserName(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line">       user.setPassword(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">       userMapper.update(user,queryWrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LambdaQueryWrapper构造器"><a href="#LambdaQueryWrapper构造器" class="headerlink" title="LambdaQueryWrapper构造器"></a>LambdaQueryWrapper构造器</h2><p>用LambdaQueryWrapper构造器可以避免字段名写错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       String userName=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">       Integer ageBegin=<span class="number">20</span>;</span><br><span class="line">       Integer ageEnd=<span class="number">50</span>;</span><br><span class="line">       LambdaQueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.like(StringUtils.isNotBlank(userName),User::getUserName,userName).ge(ageBegin!=<span class="literal">null</span>,User::getAge,ageBegin)</span><br><span class="line">                    .le(ageEnd!=<span class="literal">null</span>,User::getAge,ageEnd);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Condition组装条件"><a href="#Condition组装条件" class="headerlink" title="Condition组装条件"></a>Condition组装条件</h2><p>StringUtils.isNotBlank(userName)</p>
<p>geBegin!&#x3D;null</p>
<p>ageEnd!&#x3D;null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">        String userName=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        Integer ageBegin=<span class="number">20</span>;</span><br><span class="line">        Integer ageEnd=<span class="number">50</span>;</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.like(StringUtils.isNotBlank(userName),<span class="string">&quot;user_name&quot;</span>,userName).ge(ageBegin!=<span class="literal">null</span>,<span class="string">&quot;age&quot;</span>,ageBegin).le(ageEnd!=<span class="literal">null</span>,<span class="string">&quot;age&quot;</span>,ageEnd);</span><br><span class="line">        List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>常用工具和框架</category>
      </categories>
  </entry>
  <entry>
    <title>knife4j</title>
    <url>/2023/08/19/Knife4j/</url>
    <content><![CDATA[<h1 id="导入依赖-以2-0版本为例"><a href="#导入依赖-以2-0版本为例" class="headerlink" title="导入依赖(以2.0版本为例)"></a>导入依赖(以2.0版本为例)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">2.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="新建Knife4j配置类"><a href="#新建Knife4j配置类" class="headerlink" title="新建Knife4j配置类"></a>新建Knife4j配置类</h1><p>在config包下新建Knife4jConfiguration类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knife4jConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【重要】指定Controller包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PACKAGE</span> <span class="operator">=</span> <span class="string">&quot;cn.tedu.tmall&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;学茶商城&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主机名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;http://java.tedu.cn&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TITLE</span> <span class="operator">=</span> <span class="string">&quot;学茶商城-账号管理后台服务-在线API文档&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简介</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESCRIPTION</span> <span class="operator">=</span> <span class="string">&quot;学茶商城-账号管理后台服务-在线API文档&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务条款URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TERMS_OF_SERVICE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联系人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONTACT_NAME</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联系网址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONTACT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://java.tedu.cn&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联系邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONTACT_EMAIL</span> <span class="operator">=</span> <span class="string">&quot;java@tedu.cn&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VERSION</span> <span class="operator">=</span> <span class="string">&quot;2.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OpenApiExtensionResolver openApiExtensionResolver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Knife4jConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;创建配置类对象：Knife4jConfiguration&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .host(HOST)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(GROUP_NAME)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(BASE_PACKAGE))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .extensions(openApiExtensionResolver.buildExtensions(GROUP_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(TITLE)</span><br><span class="line">                .description(DESCRIPTION)</span><br><span class="line">                .termsOfServiceUrl(TERMS_OF_SERVICE_URL)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(CONTACT_NAME, CONTACT_URL, CONTACT_EMAIL))</span><br><span class="line">                .version(VERSION)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>需要在配置文件中添加<code>knife4j.enable=true</code>,开启配置项,不然以下会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OpenApiExtensionResolver openApiExtensionResolver;</span><br></pre></td></tr></table></figure>

<p>如果你在启动项目的时候抛出：<code>Failed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException</code>,那是因为你的 springboot 版本太高，应该是 2.6.x，由于Springfox使用的路径匹配是基于AntPathMatcher，而Spring Boot 2.6.X使用的是PathPatternMatcher，所以将MVC的路径匹配规则改成 AntPathMatcher，在配置文件中加入如下参数即可（如果没有报错，可以跳过这个环节）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="comment"># Springfox使用的路径匹配是基于AntPathMatcher的，而Spring Boot 2.6.X使用的是PathPatternMatcher</span></span><br><span class="line">      <span class="comment"># 所以需要配置此参数</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure>

<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><p>Knife4j 提供了一些常用的注解来控制 API 文档的生成和展示，以下是其中几个常用的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> `<span class="meta">@Api</span>`：用于标识一个 Controller 类作为一个 API 文档资源，可以设置该类的描述信息和分组名字。</span><br><span class="line">    (设置Controller类名字,如:用户管理模块 <span class="meta">@Api(tags = &quot;用户管理模块&quot;)</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> `<span class="meta">@ApiOperation</span>`：用于描述接口的操作，可以设置接口的名称、描述、请求方法等信息。</span><br><span class="line">    (设置Controller内方法的名字,如:增加员工功能  <span class="meta">@ApiOperation(&quot;增加员工功能&quot;)</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> `<span class="meta">@ApiParam</span>`：用于描述接口的请求参数，可以设置参数的名称、类型、描述等信息，帮助开发人员更好地理解和使用接口。</span><br><span class="line">    (通常用于没有封装并且只有一个的请求参数上 <span class="meta">@ApiParam(value = &quot;用户信息&quot;, required = true)</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> `<span class="meta">@ApiImplicitParam</span>`：用于描述隐式的接口参数，即从请求上下文中获取的参数，如路径变量、请求头等。</span><br><span class="line">    (通常用于没有封装并且有多个的请求参数上 </span><br><span class="line">     <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;email&quot;, value = &quot;电子邮箱&quot;, required = true, paramType = &quot;query&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> `<span class="meta">@ApiModel</span>`：用于对请求或响应的数据模型进行描述，可以设置模型的名称、属性等信息。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> `<span class="meta">@ApiModelProperty</span>`：用于描述一个模型属性，可以设置属性名称、描述、数据类型等信息。</span><br><span class="line">    (通常用在封装的请求参数类中,如 <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;root&quot;)</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">7.</span> ` <span class="meta">@ApiOperationSupport(order = 310)</span>`:用于在文档现实中排序,推荐开头数字根据增删改查的顺序赋值,为了方便以后添加方法,推荐使用较大值。</span><br><span class="line">    </span><br><span class="line"><span class="number">8.</span>`<span class="meta">@ApiIgnore</span>`常用在请求参数前,用来忽略不需要的文档信息。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用工具和框架</category>
      </categories>
  </entry>
  <entry>
    <title>PageHelper</title>
    <url>/2023/08/05/PageHelper/</url>
    <content><![CDATA[<h1 id="关于PageHelper框架"><a href="#关于PageHelper框架" class="headerlink" title="关于PageHelper框架"></a>关于PageHelper框架</h1><p>PageHelper框架是专门用于MyBatis的无侵入性的分页框架（是通过MyBatis拦截器实现的）。</p>
<p>在Spring Boot项目中，需要添加<code>pagehelper-spring-boot-starter</code>依赖项后才可以使用PageHelper框架：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于MyBatis或MyBatis Plus的分页查询框架 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，如果项目中已经使用MyBatis &#x2F; MyBatis Plus实现了列表查询功能，就可以直接开始处理分页，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageHelperTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CategoryMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">listByParent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNum</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 第几页</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">6</span>; <span class="comment">// 每页几条</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">parentId</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize); <span class="comment">// 设置分页，注意：这句话必须直接出现在查询之前，否则可能导致线程安全问题</span></span><br><span class="line">        List&lt;?&gt; list = mapper.listByParent(parentId);</span><br><span class="line">        <span class="keyword">for</span> (Object item : list) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：以上调用<code>PageHelper.startPage()</code>与Mapper的查询，必须是连续的2条语句，否则，可能导致线程安全问题！</p>
<h1 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h1><p>1.4.1版本已修复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">The dependencies of some of the beans in the application context form a cycle:</span><br><span class="line"></span><br><span class="line">┌──-&gt;──┐</span><br><span class="line">|  com.github.pagehelper.autoconfigure.PageHelperAutoConfiguration</span><br><span class="line">└──&lt;-──┘</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/PageHelp.png"></p>
<p>当通过PageHelper执行分页查询后，查询返回的集合将是<code>com.github.pagehelper.Page</code>类型的，是<code>ArrayList</code>的子级类型，并且，其中包含了许多分页的相关数据：</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/pagehelp2.png" style="zoom:50%;" />

<p>由于使用MyBatis查询列表时，抽象方法的返回值类型都会声明为<code>List</code>类型，则获取的返回结果不利于从中获取以上分页相关数据，为了便于获取以上分页数据，还应该结合PageHelper框架中的<code>PageInfo</code>类一起使用，将查询结果作为<code>PageInfo</code>的构造方法参数传入即可，再调用<code>PageInfo</code>对象的方法获取数据，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageInfo&lt;?&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(list);</span><br><span class="line">System.out.println(<span class="string">&quot;数据总量：&quot;</span> + pageInfo.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span> + pageInfo.getPages());</span><br></pre></td></tr></table></figure>

<h1 id="自定义分页结果类型"><a href="#自定义分页结果类型" class="headerlink" title="自定义分页结果类型"></a>自定义分页结果类型</h1><p>使用PageHelper实现分页时，结果通常使用<code>PageInfo</code>类型，但是，此类型中包含的相关数据太多，可能是没有必要的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prePage=0, </span><br><span class="line">nextPage=2, </span><br><span class="line">isFirstPage=true, </span><br><span class="line">isLastPage=false, </span><br><span class="line">hasPreviousPage=false, </span><br><span class="line">hasNextPage=true, </span><br><span class="line">navigatePages=8, </span><br><span class="line">navigateFirstPage=1, </span><br><span class="line">navigateLastPage=4, </span><br><span class="line">navigatepageNums=[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>以上数据基本上都是不必要的！</p>
<p>为了使得响应到客户端的数据是简单、有效的，可以自行定义数据类型，作为分页的数据结果，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageData</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每页记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer currentPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于将<code>PageInfo</code>转变为以上<code>PageData</code>类型的代码是相对固定的，不必要在每次分页查询时都写相同的代码进行转换，则可以：</p>
<ul>
<li>在<code>PageData</code>类上添加使用<code>PageInfo</code>参数的构造方法，在构造方法内部封装必要的数据即可</li>
<li>使用新的工具类，在此工具类提供“将<code>PageInfo</code>转换为<code>PageData</code>的方法”</li>
</ul>
<p>以使用工具类为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageInfoToPageDataConverter</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将PageHelper框架中的PageInfo类型对象转换成自定义的PageData类型对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageInfo PageInfo对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;      PageInfo对象中的列表数据中的元素数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 自定义的PageData类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; PageData&lt;T&gt; <span class="title function_">convert</span><span class="params">(PageInfo&lt;T&gt; pageInfo)</span> &#123;</span><br><span class="line">        PageData&lt;T&gt; pageData = <span class="keyword">new</span> <span class="title class_">PageData</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> pageData.setList(pageInfo.getList())</span><br><span class="line">                .setPageNum(pageInfo.getPageNum())</span><br><span class="line">                .setPageSize(pageInfo.getPageSize())</span><br><span class="line">                .setTotal(pageInfo.getTotal())</span><br><span class="line">                .setMaxPage(pageInfo.getPages());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectPage</span><span class="params">()</span> &#123;</span><br><span class="line">        Integer pageNum=<span class="number">2</span>;</span><br><span class="line">        Integer pageSize=<span class="number">5</span>;</span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectPage();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line">        PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>(users);</span><br><span class="line">        System.out.println(<span class="string">&quot;pageInfo: &quot;</span> + pageInfo);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line">        PageData&lt;User&gt; pageData = PageInfoToPageDataConverter.convert(pageInfo);</span><br><span class="line">        System.out.println(pageData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="根据父级查询子级类别列表–Repository层"><a href="#根据父级查询子级类别列表–Repository层" class="headerlink" title="根据父级查询子级类别列表–Repository层"></a>根据父级查询子级类别列表–Repository层</h1><p>在<code>ICategoryRepository</code>中添加抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据父级类别查询其子级类别列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentId 父级类别的ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageNum  页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize 每页数据量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 类别列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PageData&lt;CategoryListItemVO&gt; <span class="title function_">listByParent</span><span class="params">(Long parentId, Integer pageNum, Integer pageSize)</span>;</span><br></pre></td></tr></table></figure>

<p>并在<code>CategoryRepositoryImpl</code>中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageData&lt;CategoryListItemVO&gt; <span class="title function_">listByParent</span><span class="params">(Long parentId, Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始执行【根据父级类别查询其子级类别列表】的数据访问，父级类别：&#123;&#125;，页码：&#123;&#125;，每页数据量：&#123;&#125;&quot;</span>, parentId, pageNum, pageSize);</span><br><span class="line">    PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">    List&lt;CategoryListItemVO&gt; list = categoryMapper.listByParent(parentId);</span><br><span class="line">    PageInfo&lt;CategoryListItemVO&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(list);</span><br><span class="line">    <span class="comment">// PageData&lt;CategoryListItemVO&gt; pageData = PageInfoToPageDataConverter.convert(pageInfo);</span></span><br><span class="line">    <span class="comment">// return pageData;</span></span><br><span class="line">    <span class="comment">// 【非常不推荐】return PageInfoToPageDataConverter.convert(new PageInfo&lt;&gt;(categoryMapper.listByParent(parentId)));</span></span><br><span class="line">    <span class="keyword">return</span> PageInfoToPageDataConverter.convert(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用工具和框架</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Security</title>
    <url>/2023/08/05/Spring-Security/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring相关</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/08/20/Redis/</url>
    <content><![CDATA[<h1 id="关于Redis"><a href="#关于Redis" class="headerlink" title="关于Redis"></a>关于Redis</h1><p>Redis是一款基于内存的、使用K-V结构存储数据的NoSQL非关系型数据库。</p>
<blockquote>
<p>数据库：数据的仓库，只要能够实现数据的读写，这类的软件都可以称之为数据库，通常，在没有特定的修饰的表达中，泛指“关系型数据库”。</p>
<p>非关系型数据库：对所有的数据一视同仁，并不表现数据之间的关系。</p>
<p>NoSQL：No SQL &#x2F; No Operation SQL，不使用SQL语句操作数据库的数据。</p>
<p>基于内存的：Redis的数据是直接存储在内存中的。注意：Redis会自动的将所管理的数据同步到磁盘上，并且，在每次启动时都会自动将磁盘上的数据同步到内存中，所以，即使计算机重启或断电，Redis中的数据基本上不会丢失。</p>
</blockquote>
<p>由于Redis是基于内存的，所以，Redis的读写效率非常高！</p>
<p>Redis的主要作用是“缓存数据”，通常的表现为：将关系型数据库（例如MySQL）中的数据取出，并存入到Redis中，后续，当需要读取相关数据时，不再从关系型数据库中读取，而是优先从Redis中读取！</p>
<p>由于Redis是基于内存的，所以，读写效率远高于基于磁盘的关系型数据库，Redis的查询效率非常高，单次查询耗时更短，就可以承受更大的访问量，并减少了对关系型数据库的访问，从而起到保护关系型数据库的作用！</p>
<h1 id="Redis中的常用命令"><a href="#Redis中的常用命令" class="headerlink" title="Redis中的常用命令"></a>Redis中的常用命令</h1><p>当登录Redis客户端（命令提示符变成<code>127.0.0.1&gt;6379</code>后），可以执行Redis的相关命令：</p>
<ul>
<li><p><code>set KEY VALUE</code>：存入数据，例如<code>set username1 tom</code>，如果KEY不存在，则表示新增数据，如果KEY已经存在，则会覆盖原有的数据，所以，<code>set</code>命令既是新增数据的命令，也是修改数据的命令</p>
</li>
<li><p><code>get KEY</code>：取出数据，例如<code>get username1</code>，如果KEY存在，则返回对应的VALUE，如果KEY不存在，则返回<code>(nil)</code>，相当于Java中的<code>null</code></p>
</li>
<li><p><code>keys PATTERN</code>：根据模式（<code>PATTERN</code>）获取KEY的列表，例如<code>keys username1</code>，如果存在匹配模式的KEY，则返回这些KEY的集合，如果不存在，则返回<code>(empty list or set)</code>，在使用模式时，可以使用<code>*</code>作为通配符，例如<code>keys username*</code>，将返回所有以<code>username</code>作为前缀的KEY，甚至，你可以使用<code>keys *</code>查询所有KEY</p>
<ul>
<li><strong>注意：</strong>在生产环境中，禁止使用此命令！</li>
</ul>
</li>
<li><p><code>del KEY [KEY ...]</code>：根据若干个KEY（至少1个）删除数据，将返回受影响的数据量，例如执行<code>delete age1</code>，当此KEY存在时，将返回<code>(integer) 1</code>，当此KEY不存在时，将返回<code>(integer) 0</code></p>
</li>
<li><p><code>flushdb</code>：清空当前数据库</p>
</li>
</ul>
<p>更多命令可参考：<a href="https://www.cnblogs.com/antLaddie/p/15362191.html">https://www.cnblogs.com/antLaddie/p/15362191.html</a></p>
<h1 id="Redis中的数据类型"><a href="#Redis中的数据类型" class="headerlink" title="Redis中的数据类型"></a>Redis中的数据类型</h1><p>Redis中的经典数据类型有5种，分别是：string（一般值，例如字符串、数值等可以直接字面表示的） &#x2F; list &#x2F; set &#x2F; hash（对象，对应Java语句中的<code>Map</code>） &#x2F; zset</p>
<p>另外，还有：bitmap &#x2F; hyperloglog &#x2F; Geo &#x2F; Stream</p>
<h1 id="Redis中的list类型"><a href="#Redis中的list类型" class="headerlink" title="Redis中的list类型"></a>Redis中的list类型</h1><p>在Redis中，list类型的数据使用的是先进后出、后进先出的栈结构：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230807173334560.png" alt="image-20230807173334560"></p>
<p>在学习Redis时，应该把Redis中的栈结构水平旋转90度来理解！</p>
<p>在操作Redis中的list数据时，可以从左侧进行压栈或弹栈的操作，例如：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230807173738567.png" alt="image-20230807173738567"></p>
<p>也可以从右侧进行压栈或弹栈的操作，例如：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230807173823476.png" alt="image-20230807173823476"></p>
<p>当从Redis中读取list的数据时，<strong>始终从左至右读取数据</strong>，通常，为了符合绝大多数开发者的使用习惯，会采“从右侧压入数据”的做法。</p>
<p>在Redis的list中，每个数据都有2个下标值，分别是从左至右、从0开始顺序递增的下标，和从右至左、从-1开始顺序递减的下标，例如：</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230807175650692.png" alt="image-20230807175650692"></p>
<p>注意：在获取list的数据区间时，必须保证start在end的左侧！</p>
<h1 id="Redis编程"><a href="#Redis编程" class="headerlink" title="Redis编程"></a>Redis编程</h1><p>在基于Spring Boot的项目中，实现Redis编程需要添加<code>spring-boot-starter-data-redis</code>依赖项。</p>
<p>然后，需要使用<code>RedisTemplate</code>工具类的API实现Redis编程，通常会在配置类中使用<code>@Bean</code>方法来配置<code>RedisTemplate</code>，则后续可以在任何组件类中自动装配<code>RedisTemplate</code>，然后调用相关访问来访问数据。</p>
<p>关于配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.tmall.admin.mall.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title function_">redisTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">            RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Redis缓存数据"><a href="#使用Redis缓存数据" class="headerlink" title="使用Redis缓存数据"></a>使用Redis缓存数据</h1><p>把关系型数据库中的数据存储到Redis中，并且，后续需要查询数据时，将优先从Redis中查询（如果Redis中没有，则从关系型数据库中查询，或，如果Redis中没有，直接返回没有数据的结果），这种做法就叫“缓存”数据。</p>
<p>当使用Redis缓存数据后，将存在<strong>数据一致性</strong>的问题！其典型表现就是：如果关系型数据库中的数据发生了变化，但是，Redis中的数据没有及时一并调整，就会导致Redis中的数据与关系型数据库中的数据并不一致！</p>
<p>对于数据一致性问题，首先，要学会区分，你需要的到底是实时一致性，还是最终一致性。</p>
<p>并且，虽然Redis适合缓存大量的数据，但是，如果某些数据的访问频率非常低，其实，也没有必要缓存到Redis中（需要查询时，直接从关系型数据库中查询即可），否则，任何数据都缓存到Redis中，则任何数据都需要处理数据一致性问题。</p>
<p>所以，适合使用Redis缓存的数据应该是：</p>
<ul>
<li>访问频率较高，甚至很高</li>
<li>对数据一致性要求并不严格</li>
<li>数据被修改的频率非常低</li>
</ul>
<p>关于数据一致问题的解决方案大致有：</p>
<ul>
<li>实时同步：修改关系型数据库中的数据时，也一并修改Redis中缓存的数据</li>
<li>手动同步：修改关系型数据库中的数据时，不会修改Redis中缓存的数据，仅当管理人员手动操作后，才会将关系型数据库的数据同步到Redis中</li>
<li>定时同步：修改关系型数据库中的数据时，不会修改Redis中缓存的数据，但每间隔一段时间，或到了某个特定的时间点，就会自动将关系型数据库的数据同步到Redis中</li>
</ul>
<h1 id="使用Redis缓存资讯的类别列表"><a href="#使用Redis缓存资讯的类别列表" class="headerlink" title="使用Redis缓存资讯的类别列表"></a>使用Redis缓存资讯的类别列表</h1><p>首先，使用公共的接口文件定义Redis中的数据的Key值，例如，在<code>tmall-common</code>项目中创建此接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContentCacheConsts</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">KEY_CATEGORY_LIST</span> <span class="operator">=</span> <span class="string">&quot;content:category:list&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在<code>repository</code>层实现读写Redis，则先在项目的根包下创建<code>dao.cache.ICategoryCacheRepository</code>接口，此接口应该继承自以上定义Key值的接口，则此接口的实现类可以直接使用以上Key值，并在接口中声明抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICategoryCacheRepository</span> <span class="keyword">extends</span> <span class="title class_">ContentCacheConsts</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveList</span><span class="params">(List&lt;CategoryListItemVO&gt; categoryList)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;CategoryListItemVO&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目的根包下创建<code>dao.cache.impl.CategoryCacheRepositoryImpl</code>类，实现以上接口，并重写接口中定义的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryCacheRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">ICategoryCacheRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Serializable&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveList</span><span class="params">(List&lt;CategoryListItemVO&gt; categoryList)</span> &#123;</span><br><span class="line">        ListOperations&lt;String, Serializable&gt; opsForList = redisTemplate.opsForList();</span><br><span class="line">        <span class="keyword">for</span> (CategoryListItemVO category : categoryList) &#123;</span><br><span class="line">            opsForList.rightPush(KEY_CATEGORY_LIST, category);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CategoryListItemVO&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        ListOperations&lt;String, Serializable&gt; opsForList = redisTemplate.opsForList();</span><br><span class="line">        <span class="type">List</span> <span class="variable">range</span> <span class="operator">=</span> opsForList.range(KEY_CATEGORY_LIST, start, end);</span><br><span class="line">        <span class="keyword">return</span> range;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，需要在<code>service</code>层调用读写Redis的<code>repository</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageData&lt;CategoryListItemVO&gt; <span class="title function_">list</span><span class="params">(Integer pageNum)</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始处理【查询类别列表】的业务，页码：&#123;&#125;&quot;</span>, pageNum);</span><br><span class="line">    <span class="comment">// return categoryRepository.list(pageNum, defaultQueryPageSize);</span></span><br><span class="line">    List&lt;CategoryListItemVO&gt; list = categoryCacheRepository.list();</span><br><span class="line">    PageData&lt;CategoryListItemVO&gt; pageData = <span class="keyword">new</span> <span class="title class_">PageData</span>&lt;&gt;();</span><br><span class="line">    pageData.setList(list);</span><br><span class="line">    pageData.setMaxPage(<span class="number">1</span>);</span><br><span class="line">    pageData.setPageSize(list.size());</span><br><span class="line">    pageData.setTotal(list.size() + <span class="number">0L</span>);</span><br><span class="line">    pageData.setPageNum(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过以上调整后，即可达成新的效果，Controller并不需要做任何调整。</p>
<h1 id="使用ApplicationRunner缓存预热"><a href="#使用ApplicationRunner缓存预热" class="headerlink" title="使用ApplicationRunner缓存预热"></a>使用ApplicationRunner缓存预热</h1><p>在Spring Boot项目中，自定义组件类，实现<code>ApplicationRunner</code>接口，则重写的方法会在项目启动时自动执行，可以在此重写的方法中向Redis存入缓存的数据，即可实现缓存预热（启动项目时即加载缓存数据到Redis中）。</p>
<p>示例代码：<code>ICategoryService</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重建缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rebuildCache</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>示例代码：<code>CategoryServiceImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebuildCache</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;CategoryListItemVO&gt; list</span><br><span class="line">            = categoryRepository.list(<span class="number">1</span>, Integer.MAX_VALUE).getList();</span><br><span class="line">    categoryCacheRepository.deleteList();</span><br><span class="line">    categoryCacheRepository.saveList(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：<code>CategoryCachePreload</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryCachePreload</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ICategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        categoryService.rebuildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><p>在Spring Boot项目中，自定义组件类，并在组件中自定义方法，在方法上添加<code>@Scheduled</code>注解并配置计划任务的执行规则，即可使用计划任务。</p>
<p>注意：在Spring Boot项目中，默认并不允许执行计划任务，必须在配置类上添加<code>@EnableScheduling</code>注解以开启，才允许执行计划任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryCacheSchedule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixedRate：执行频率，以【上一次开始执行的时间】来计算下一次的执行时间，以毫秒为单位</span></span><br><span class="line">    <span class="comment">// fixedDelay：执行间隔，以【上一次执行结束的时间】来计算下一次的执行时间，以毫秒为单位</span></span><br><span class="line">    <span class="comment">// cron：使用cron表达式来配置，cron表达式的值是一个字符串，由6~7个域组成，各域之间使用空格分隔</span></span><br><span class="line">    <span class="comment">// -- 在cron表达式中，各域从左至右分别表示：秒 分 时 日 月 周（星期） [年]</span></span><br><span class="line">    <span class="comment">// -- 各域的值可以使用通配符</span></span><br><span class="line">    <span class="comment">// -- 使用星号（*）表示任意值</span></span><br><span class="line">    <span class="comment">// -- 使用问号（?）表示不关心此域的值，仅可以用于“日”和“周”这2个域的值</span></span><br><span class="line">    <span class="comment">// -- 各域的值可以使用 x/y 格式的值，x表示起始值，y表示间隔周期</span></span><br><span class="line">    <span class="comment">// -- 例如在“分”的域位置设置为 1/5，则表示“分”的值为1时开始执行，且每间隔5分钟执行一次</span></span><br><span class="line">    <span class="comment">// cron表达式示例：</span></span><br><span class="line">    <span class="comment">// &quot;56 34 12 13 2 ? 2023&quot;表示：2023年2月13日12:34:56执行任务，不关心当天星期几</span></span><br><span class="line">    <span class="comment">// &quot;0/30 * * * * ?&quot;表示：每分钟的0秒时执行，且每30秒执行一次</span></span><br><span class="line">    <span class="comment">// 更多内容参考：</span></span><br><span class="line">    <span class="comment">// https://segmentfault.com/a/1190000021574315</span></span><br><span class="line">    <span class="comment">// https://blog.csdn.net/study_665/article/details/123506946</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 10 ? 8 MON&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebuildCache</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;CategoryCacheSchedule.rebuildCache()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于Redis中的hash类型"><a href="#关于Redis中的hash类型" class="headerlink" title="关于Redis中的hash类型"></a>关于Redis中的hash类型</h1><p>在Redis中的hash类型对应Java中的<code>Map</code>类型。</p>
<p>建议添加<code>hutool</code>依赖，以实现对象与Map的相互转换：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hutool.version</span>&gt;</span>5.8.15<span class="tag">&lt;/<span class="name">hutool.version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hutool：小工具集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>读写hash数据示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存入hash类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">hashPutAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();</span><br><span class="line">    category.setId(<span class="number">998L</span>);</span><br><span class="line">    category.setName(<span class="string">&quot;测试类别998&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// map.put(&quot;id&quot;, category.getId());</span></span><br><span class="line">    <span class="comment">// map.put(&quot;name&quot;, category.getName());</span></span><br><span class="line">    Map&lt;String, Object&gt; map = BeanUtil.beanToMap(category);</span><br><span class="line"></span><br><span class="line">    HashOperations&lt;String, Object, Object&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;mall:category:item:998&quot;</span>;</span><br><span class="line">    opsForHash.putAll(key, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Redis中的hash数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">hashEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;mall:category:item:998&quot;</span>;</span><br><span class="line">    HashOperations&lt;String, Object, Object&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">    Map&lt;Object, Object&gt; entries = opsForHash.entries(key);</span><br><span class="line">    System.out.println(entries);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Category category = new Category();</span></span><br><span class="line">    <span class="comment">// category.setId(Long.valueOf(entries.get(&quot;id&quot;).toString()));</span></span><br><span class="line">    <span class="comment">// category.setName(entries.get(&quot;name&quot;).toString());</span></span><br><span class="line">    <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> BeanUtil.mapToBean(entries, Category.class, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(category);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Validation</title>
    <url>/2023/08/19/Spring-Validation/</url>
    <content><![CDATA[<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Spring Boot支持Validation的依赖项 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">               &lt;spring-boot.version&gt;<span class="number">2.5</span><span class="number">.0</span>&lt;/spring-boot.version&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><p>通常用在</p>
<p>@NotNull：不允许为null值</p>
<p>可用于任何类型的参数</p>
<p>@NotEmpty：不允许为空字符串，即长度为0的字符串</p>
<p>仅用于检查字符串类型的参数</p>
<p>@NotBlank：不允许为空白的字符串，即仅由空格或TAB制表位或换行组成的值</p>
<p>仅用于检查字符串类型的参数</p>
<p>@Length：限制字符串的长度</p>
<p>@Pattern：通过正则表达式检查字符串的格式，此注解的regexp属性就是定义正则表达式的属性</p>
<p>仅用于检查字符串类型的参数</p>
<p>@Min：限制整型数值的最小值</p>
<p>仅用于检查整型数值参数</p>
<p>@Max：限制整型数值的最大值</p>
<p>仅用于检查整型数值参数</p>
<p>@Range：限制整型数值的取值区间，默认最小值为0，最大值为long的上限值</p>
<p>仅用于检查整型数值参数</p>
<h1 id="在模型参数对象字段上-请求参数-添加注解"><a href="#在模型参数对象字段上-请求参数-添加注解" class="headerlink" title="在模型参数对象字段上(请求参数)添加注解"></a>在模型参数对象字段上(请求参数)添加注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Positive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Positive(message = &quot;年龄必须为正数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="在控制器类上或请求方法的请求参数上添加注解"><a href="#在控制器类上或请求方法的请求参数上添加注解" class="headerlink" title="在控制器类上或请求方法的请求参数上添加注解"></a>在控制器类上或请求方法的请求参数上添加注解</h1><p>可以用在类名上添加<code>@Validated</code>对所有方法验证,也可以添加在具体的参数前面对具体方法验证</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p><code>@Validated</code> 和 <code>@Valid</code> 是 Spring 中用于参数验证的注解，它们之间有以下区别：</p>
<ol>
<li><p><code>@Validated</code> 是 Spring 提供的注解，而 <code>@Valid</code> 是 Java 标准的 Bean Validation（JSR-303）提供的注解。</p>
</li>
<li><p><code>@Validated</code> 注解提供了一些额外功能，例如分组验证、级联验证等，这些功能在 Bean Validation 中并不存在。</p>
</li>
<li><p><code>@Validated</code> 注解是 Spring 特有的，在 Spring 的环境中起作用。它基于 AOP（面向切面编程）实现，使用了 Spring 的校验器（Validator）进行验证。</p>
</li>
<li><p><code>@Valid</code> 注解是 Bean Validation 的标准注解，它可以在任何符合 Bean Validation 规范的环境下使用，不依赖于 Spring。</p>
</li>
</ol>
<p>要选择使用哪个注解取决于你的具体需求和使用的框架。</p>
<ul>
<li>如果你使用的是 Spring 框架，并且需要使用一些特定于 Spring 的功能，如分组验证、级联验证等，那么你可以选择使用 <code>@Validated</code> 注解。</li>
<li>如果你只需要进行基本的参数验证，并且希望能够在任何符合 Bean Validation 规范的环境中使用，那么你可以选择使用 <code>@Valid</code> 注解。</li>
</ul>
<p>需要注意的是，无论选择哪个注解，都需要确保你的项目中包含了相应的验证框架和依赖。例如，使用 <code>@Valid</code> 注解需要在 classpath 中包含 Bean Validation 的相关库，如 Hibernate Validator。而使用 <code>@Validated</code> 注解则需要 Spring 的相关依赖。</p>
]]></content>
      <categories>
        <category>Spring相关</category>
      </categories>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/2023/08/20/Nacos/</url>
    <content><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="Nacos介绍"><a href="#Nacos介绍" class="headerlink" title="Nacos介绍"></a>Nacos介绍</h2><p>官网: <a href="https://nacos.io/en-us/docs/v2/what-is-nacos.html">https://nacos.io/en-us/docs/v2/what-is-nacos.html</a></p>
<p>Nacos 致力于帮助您<strong>发现</strong>、<strong>配置</strong>和管理<strong>微服务</strong>。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos在微服务架构中,实现使用的功能包括 服务治理,配置的管理.</p>
<p>当前市场上任何一种微服务落地方案,都需要这种软件存在,即使不使用nacos,也需要别的相同功能的软件技术来代替(console eureka zookeeper)</p>
<p>核心功能:</p>
<p><strong>注册中心</strong></p>
<p>​	发现(抓取 查询)</p>
<p>​    注册(新增)</p>
<p><strong>配置中心</strong></p>
<h2 id="准备nacos环境"><a href="#准备nacos环境" class="headerlink" title="准备nacos环境"></a>准备nacos环境</h2><p>nacos的使用结构</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816144059439.png" alt="image-20230816144059439" style="zoom:50%;" />

<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><ul>
<li>nacos服务端–解压安装包</li>
</ul>
<p>客户端软件包需要从官网下载,比较慢,课前资料中,准备了一个已经下载好的zip包.</p>
<p>解压到一个<strong>没有中文,没有空格</strong>的路径.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816144257043.png" alt="image-20230816144257043" style="zoom: 67%;" />

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816144422374.png" alt="image-20230816144422374" style="zoom:50%;" />

<ul>
<li>启动nacos–运行脚本</li>
</ul>
<p>进入到nacos的家目录的\bin文件夹,在命令行中,执行命令</p>
<p>windows</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>mac 两种启动方式</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">./startup.sh -m standalone</span><br><span class="line">startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816144918127.png" alt="image-20230816144918127" style="zoom:50%;" />

<h3 id="启动服务端可能出现的问题"><a href="#启动服务端可能出现的问题" class="headerlink" title="启动服务端可能出现的问题"></a>启动服务端可能出现的问题</h3><ul>
<li>没有JAVA_HOME 提示错误</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816145151224.png" alt="image-20230816145151224"></p>
<p>在当前操作系统中,没有提供JAVA_HOME 环境变量.</p>
<p><strong>注意: 请配置一个jdk1.8的环境,并且,不要有空格</strong></p>
<p>配置windows环境变量.</p>
<ol>
<li>控制面版 搜索高级系统设置</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816145706835.png" alt="image-20230816145706835"></p>
<ol start="2">
<li>进入环境变量配置</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816145749200.png" alt="image-20230816145749200"></p>
<ul>
<li>新建环境变量</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816145838969.png" alt="image-20230816145838969"></p>
<ul>
<li>新建填写JAVA_HOME</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816150103065.png" alt="image-20230816150103065"></p>
<ul>
<li>确定所有</li>
</ul>
<h3 id="停止关闭nacos服务端"><a href="#停止关闭nacos服务端" class="headerlink" title="停止关闭nacos服务端"></a>停止关闭nacos服务端</h3><p>直接在cmd窗口 或者终端 ctrl+c.</p>
<p>看到提示符行重新出现.</p>
<h2 id="nacos控制台页面"><a href="#nacos控制台页面" class="headerlink" title="nacos控制台页面"></a>nacos控制台页面</h2><p>nacos服务端启动后,会提供一个可以访问的页面控制台,经常需要去访问</p>
<p><a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> 访问登录控制台</p>
<p>用户名密码:  nacos&#x2F;nacos</p>
<h3 id="控制台菜单简介"><a href="#控制台菜单简介" class="headerlink" title="控制台菜单简介"></a>控制台菜单简介</h3><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816153113674.png" alt="image-20230816153113674"></p>
<ol>
<li>配置管理: nacos作为配置中心保存管理的数据显示</li>
<li>服务管理: nacos作为注册中心保存的服务数据显示</li>
<li>权限管理(不用):  典型的用户 角色 权限管理的逻辑</li>
<li>命名空间: 管理不同开发环境的配置和注册信息隔离的相关内容</li>
<li>集群管理(不用): 如果nacos集群启动的,集群管理可以对集群中的nacos节点做管理操作,下线,查看状态.</li>
</ol>
<h2 id="nacos的客户端配置"><a href="#nacos的客户端配置" class="headerlink" title="nacos的客户端配置"></a>nacos的客户端配置</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>是一个web应用绑定的组件.每个nacos客户端可以通过web应用的配置,和服务端进行逻辑交互,帮助web应用整合到微服务框架组件结构中.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816153952492.png" alt="image-20230816153952492" style="zoom:50%;" />

<h3 id="Springboot整合nacos"><a href="#Springboot整合nacos" class="headerlink" title="Springboot整合nacos"></a>Springboot整合nacos</h3><p>springboot存在,任何经过整理优化的软件技术,可以通过非常简单的步骤完成</p>
<ol>
<li>依赖</li>
<li>yaml配置(交给底层配置类)</li>
<li>做一些简单的代码配置或者注解的使用</li>
</ol>
<p>选择案例演示-stock**&#x2F;cart**</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入nacos的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#spring 应用名称</span></span><br><span class="line">  <span class="comment">#微服务中 服务名称</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">luban-demo-cart</span></span><br><span class="line">  <span class="comment">#微服务 nacos客户端配置属性</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 提供给当前底层客户端nacos的服务端地址 域名:端口</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>

<p>nacos客户端整合没有配置类和注解使用的需求,所以只有2步需要.</p>
<p>将cart-adapter启动,观察一下日志文件. 观察nacos的控制台.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816160109450.png" alt="image-20230816160109450" style="zoom:50%;" />



<h3 id="客户端和服务端交互基本原理"><a href="#客户端和服务端交互基本原理" class="headerlink" title="客户端和服务端交互基本原理"></a>客户端和服务端交互基本原理</h3><p>nacos服务端支持http协议的访问.可以将其当成一个支持http协议web服务.</p>
<p>nacos客户端只要通过http协议访问nacos服务端暴露的接口,就可以实现和服务端交互</p>
<p>通过官网提供的信息.</p>
<p>nacos服务端 具备一个接收post请求的接口地址</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/nacos/v1/ns/instance</span><br></pre></td></tr></table></figure>

<p>nacos客户端请求到这个地址,携带一些参数,可以在nacos服务生成注册信息(服务信息)</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">serviceName=luban-demo-stock&amp;ip=20.18.7.10&amp;port=8080</span><br></pre></td></tr></table></figure>

<p>可以使用任何支持http请求的插件 实现在nacos服务端进行注册测试,比如postman</p>
<p>比如 curl命令.</p>
<p>curl 支持http协议访问的插件命令.用法:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">curl -X [METHOD] args目标地址</span><br></pre></td></tr></table></figure>

<p>如果使用curl发送一个post请求</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://localhost:8848/nacos/v1/ns/instance?serviceName=test-demo&amp;ip=127.0.0.1&amp;port=10010&quot;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816164745744.png" alt="image-20230816164745744" style="zoom:50%;" />

<ul>
<li>结论1:<ul>
<li>客户端nacos进程已经组织好了所有的交互代码逻辑,无需我们介入,我们只需要将这个客户端进程整合到web应用.自动和服务交互,注册当前服务实例信息.携带当前web应用中服务名称(spring.application.name),ip(自动获取),port(server.port).服务端会记录保存这个数据到内存.</li>
</ul>
</li>
</ul>
<p>nacos服务端除了提供注册的接口(新增),还提供了一个抓取的接口(查询)</p>
<p>接口地址:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/nacos/v1/ns/instance/list</span><br></pre></td></tr></table></figure>

<p>通过这个接口,可以传递参数,获取某个服务的详细信息.</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">serviceName=luban-demo-stock</span><br></pre></td></tr></table></figure>

<p>通过curl命令来测试</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;http://localhost:8848/nacos/v1/ns/instance/list?serviceName=luban-demo-cart-haha&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.6.132&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">10005</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;valid&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;healthy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;marked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instanceId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.6.132#10005#DEFAULT#DEFAULT_GROUP@@luban-demo-cart-haha&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;preserved.register.source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SPRING_CLOUD&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;serviceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;luban-demo-cart-haha&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ephemeral&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;luban-demo-cart-haha&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT_GROUP@@luban-demo-cart-haha&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cacheMillis&quot;</span><span class="punctuation">:</span> <span class="number">3000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastRefTime&quot;</span><span class="punctuation">:</span> <span class="number">1692176089735</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;checksum&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e12bd76eb3558f8f25b480393365ea08&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;useSpecifiedURL&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;clusters&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230816174705442.png" alt="image-20230816174705442"></p>
<p><strong>结论2</strong></p>
<p>nacos客户端进程 除了进行注册以外,还会根据自己的需求,对nacos服务端保存的注册信息进行抓取.隔一段时间进行更新.</p>
<h1 id="nacos客户端yaml详解"><a href="#nacos客户端yaml详解" class="headerlink" title="nacos客户端yaml详解"></a>nacos客户端yaml详解</h1><h2 id="临时实例-永久实例"><a href="#临时实例-永久实例" class="headerlink" title="临时实例 永久实例"></a>临时实例 永久实例</h2><p><strong>概念</strong>: 服务 服务实例(每一个web应用进程). 在一个服务中,服务实例多个</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817091643971.png" alt="image-20230817091643971" style="zoom:50%;" />

<p><strong>插入技巧</strong>: 将项目添加一个插件资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--springboot构建插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>java 命令运行jar包 之前,先mvn package</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar **.jar -Xmx128m --server.port=1000</span><br></pre></td></tr></table></figure>

<p>java -jar运行的是jar包文件,后面根据需求可以添加启动选项</p>
<p>– yaml中的属性和值的选项是可以覆盖springboot源文件的</p>
<p>当前启动进程是永久实例还是临时实例 true 表示临时实例 false表示永久实例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">ephemeral:</span> </span><br></pre></td></tr></table></figure>

<p>永久实例:nacos永远不删除的注册信息,就是永久实例.</p>
<p>临时实例:暂时为某些应用,环境准备的扩容实例,就是定义为临时实例.</p>
<p>为什么要分永久实例和临时实例:</p>
<p>淘宝每一个功能都是一个<strong>服务</strong>,而且具备<strong>多个实例</strong>,平日访问是<strong>固定流量</strong>,所以使用永久实例支持,如果双11来临,<strong>流量激增</strong>,需要增加临时实例,等待11完成,删除临时实例</p>
<h2 id="服务实例的ip地址"><a href="#服务实例的ip地址" class="headerlink" title="服务实例的ip地址"></a>服务实例的ip地址</h2><p>ip值是nacos客户端默认情况下根据寻找网卡的逻辑,自动从某一个网卡获取的ip地址.</p>
<p><strong>概念</strong>: 服务器多网卡,每个网卡都有本机的一个ip地址网段,功能不一样,网络范围也不一样.</p>
<p>如果ip地址是nacos自己选的,不一定能够选择正确的ip地址.</p>
<p>正确的ip地址: 在nacos注册的ip 如果被别人抓取到,能够正常访问服务实例的ip地址.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">ip:</span> </span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>开发过程中,使用的开发,测试,上线环境是不同.所以nacos提供隔离的环境.</p>
<p>不同的环境 对应使用微服务框架的时候,nacos注册在不同的命名空间.</p>
<ul>
<li>nacos默认命名空间-public</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817101522647.png" alt="image-20230817101522647"></p>
<p>nacos客户端配置的时候没有指定命名空间,默认使用public</p>
<ul>
<li>创建命名空间</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817101902565.png" alt="image-20230817101902565"></p>
<ul>
<li>nacos客户端指定注册命名空间</li>
</ul>
<p>使用属性配置namespace</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">namespace:</span> </span><br></pre></td></tr></table></figure>

<p>配置命名空间的值,就是id. 36beb5da-ce42-49bc-937a-7cef0b1406d4</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817102744053.png" alt="image-20230817102744053" style="zoom:50%;" />

<h2 id="分组配置"><a href="#分组配置" class="headerlink" title="分组配置"></a>分组配置</h2><p>NACOS管理的注册信息,同一个命名空间下有多个服务,但是服务注册可以放到<strong>不同的分组.</strong></p>
<p>分组的主要目的是–<strong>灰度发布</strong>. 同时在环境中 存在多个版本不同的服务端进程.</p>
<p>通过nacos客户端属性配置,默认不填写group 叫做DEFUALT_GROUP</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">group:</span> </span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817103259615.png" alt="image-20230817103259615" style="zoom:50%;" />

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817104031372.png" alt="image-20230817104031372"></p>
<h2 id="服务剔除"><a href="#服务剔除" class="headerlink" title="服务剔除"></a>服务剔除</h2><p>nacos实例,作为一个进程,内部包含了一个nacos客户端,在启动注册之后,需要和nacos服务端建立一个健康状态检测机制.</p>
<p><strong>永久实例:</strong> nacos服务端会进行下探. 主动询问. 如果下探发现没有响应,记录健康状态为false.下探不会停止.</p>
<p><strong>临时实例:</strong> 临时实例自己,主动上报(心跳检测). nacos服务端记录每次上报的时间戳.</p>
<p>服务端会根据时间戳的值,判断是否健康,是否剔除.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">heart-beat-interval:</span> <span class="number">5</span></span><br><span class="line">				<span class="attr">ip-delete-timeout:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>时间具体设置的值,取决于什么因素.</p>
<ul>
<li><p>超时时间不能小于 间隔时间.</p>
</li>
<li><p>取决于网络因素</p>
<ul>
<li>网络畅通,抖动没有: 时间缩小 5 10</li>
<li>网络经常抖动.放大 10 60</li>
</ul>
</li>
</ul>
<h2 id="利用原理做现象分析"><a href="#利用原理做现象分析" class="headerlink" title="利用原理做现象分析"></a>利用原理做现象分析</h2><ul>
<li><p>启动一个cart永久实例 默认分组 默认命名空间 默认ip读取</p>
</li>
<li><p>停止这个永久实例 nacos下探找不到 记录不健康</p>
</li>
<li><p>修改属性变成临时实例 自定义分组 自定义命名空间 自定义ip</p>
</li>
<li><p>永久实例转变成健康 nacos利用当初永久实例的注册信息可以下探成功</p>
</li>
<li><p>停止的临时实例 nacos接收不到主动上报的心跳 记录不健康 过一段时间将注册信息提出</p>
</li>
<li><p>修改属性另一个自定义ip地址 临时实例启动 注册新的注册信息,和刚才临时实例在nacos记录的不是同一个对象.重新记录心跳时间戳</p>
</li>
</ul>
<h1 id="nacos-配置中心"><a href="#nacos-配置中心" class="headerlink" title="nacos 配置中心"></a>nacos 配置中心</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>开发学习一个微服务架构,其中会有很多的服务,每个服务又有很多的实例.</p>
<p>每个服务开发过程中,需要编辑配置大量的web文件,比如 yaml,json,html,xml,….</p>
<p>这么多配置文本,是不方便统一管理的. 特点: 重复,同时变动…</p>
<p><strong>在多团队和多人员开发的场景中,一般这种文件都要交给配置中心管理.</strong></p>
<h2 id="管理结构"><a href="#管理结构" class="headerlink" title="管理结构"></a>管理结构</h2><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817114540807.png" alt="image-20230817114540807"></p>
<h2 id="实现nacos配置客户端整合"><a href="#实现nacos配置客户端整合" class="headerlink" title="实现nacos配置客户端整合"></a>实现nacos配置客户端整合</h2><p>需求: 在三个服务进程中,选取一个做案例 <strong>cart</strong>&#x2F;stock 整合步骤</p>
<ol>
<li><p>依赖 nacos config 客户端</p>
</li>
<li><p>yaml属性 告诉nacos 到哪个服务端读取哪些文件</p>
</li>
<li><p>简单配置代码或注解</p>
<p><strong>第一步</strong>.依赖</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入nacos依赖-配置中心客户端依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为属性配置yaml准备的一个依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		<strong>第二步</strong>: yaml配置</p>
<p>在项目中引入一个bootstrap.yaml配置文件.</p>
<p>如果当前 springboot版本是2.3.X 或更早,不需要引用依赖spring-cloud-starter-bootstrap.</p>
<p>但是如果springboot高于2.3.X(2.5.9) 需要引用.</p>
<p>引入的新的配置文件,和application.yml配置文件区别是什么?</p>
<ul>
<li>bootstrap.yaml先于application.yaml加载</li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817142933153.png" alt="image-20230817142933153" style="zoom:50%;" />

<p>bootstrap.yaml 应该只需要支持 nacosConfig客户端连接远程配置中心即可</p>
<ul>
<li>配置bootstrap的格式</li>
</ul>
<ol>
<li>如果不区分开发环境,和application.yaml没区别</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 连接配置中心的时候需要配置客户端提供的参数</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">luban-demo-cart</span></span><br><span class="line">  <span class="comment"># 微服务配置管理</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span> </span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>区分开发环境,和application配置稍有区别</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 连接配置中心的时候需要配置客户端提供的参数</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">luban-demo-cart</span></span><br><span class="line">  <span class="comment"># 微服务配置管理</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 连接配置中心的时候需要配置客户端提供的参数</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">luban-demo-cart</span></span><br><span class="line">  <span class="comment"># 微服务配置管理</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">100.99</span><span class="number">.11</span><span class="number">.11</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<h2 id="配置远程文件"><a href="#配置远程文件" class="headerlink" title="配置远程文件"></a>配置远程文件</h2><p>默认情况下,没有指定远程文件名称(dataId),当前nacosConfig客户端也会在启动后读取</p>
<p><img src="D:\IDEA\IdeaProjects\jsd2304-notes\notes\DAY04\images\image-20230817144439161.png" alt="image-20230817144439161"></p>
<ol>
<li><p>{spring.application.name}</p>
</li>
<li><p>{spirng.application.name}.{file-extension}</p>
</li>
<li><p>{spring.application.name}-{spring.profiles.active}.{file-extension}</p>
</li>
</ol>
<p>文件名称都是基于在bootstrap.yaml配置文件里指定属性值的</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">luban-demo-cart</span></span><br><span class="line"><span class="attr">file-extension</span> <span class="string">没给默认值 properties</span></span><br><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>在远程配置中心提供这个三个文件中的一个.</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817145035544.png" alt="image-20230817145035544"></p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817145214019.png" alt="image-20230817145214019"></p>
<h2 id="本地配置远程化"><a href="#本地配置远程化" class="headerlink" title="本地配置远程化"></a>本地配置远程化</h2><p>保证能够读取到远程1个或者多个文件的前提下,可以将本地公用配置</p>
<p>spring.datasource,从本地移除,放到远程文件.</p>
<p>由于默认读取的文件,不一定满足文件后缀,格式的要求,而且,不能实现多个服务的共性化读取.所以我们需要指定让当前项目读取某一个,某几个文件.</p>
<ul>
<li>yaml属性 bootstrap.yaml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">luban-demo-cart</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">datasource.yaml</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">mybatis.yaml</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">nacos-registry.yaml</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>bootstrap.yaml配置内容如上:</p>
<ul>
<li>帮助nacosconfig客户端提前连接nacosconfig服务端读取指定文件</li>
<li>如果没指定文件 没有配置shared-configs,会根据spring.applicaiton.name 和spring.profiles.active,和spring.cloud.nacos.config.file-extensions属性值,读取默认的三个文件.</li>
<li>通过shared-configs配置指定文件,可以实现公用文件的读取. 指定读取三个文件 datasource.yaml(spring.datasource.url) nacos-registry.yaml(spring.cloud.nacos.discovery.server-addr),mybatis.yaml(mybatis.configuration.**)</li>
</ul>
<h1 id="nacos阶段性总结"><a href="#nacos阶段性总结" class="headerlink" title="nacos阶段性总结"></a>nacos阶段性总结</h1><h2 id="阶段性架构"><a href="#阶段性架构" class="headerlink" title="阶段性架构"></a>阶段性架构</h2><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230817163656293.png" alt="image-20230817163656293"></p>
<h2 id="nacos核心内容"><a href="#nacos核心内容" class="headerlink" title="nacos核心内容"></a>nacos核心内容</h2><p>nacos能实现什么功能?</p>
<ul>
<li>注册中心</li>
<li>配置中心</li>
</ul>
<p>nacos角色有哪些?</p>
<ul>
<li><p>注册中心</p>
<ul>
<li><strong>服务端</strong>: 提供进程,管理对外暴露的接口,等待客户端连接</li>
<li>客户端: 访问服务端接口,进行注册和抓取(心跳)</li>
</ul>
</li>
<li><p>配置中心</p>
<ul>
<li><strong>服务端</strong>(和注册中心服务端同一个进程):</li>
<li>客户端: 访问服务端接口,进行获取配置文件的请求</li>
</ul>
</li>
</ul>
<p>nacos在哪用?怎么用</p>
<ul>
<li>面向服务编程的时候,每一个单独服务进程中使用(cart order stock 拆分的项目)</li>
<li>服务端进程需要启动,需要访问.</li>
<li>nacos客户端逻辑整合到web应用<ul>
<li>依赖(spring-cloud-starter-alibaba-nacos-discovery)</li>
<li>yaml配置(大量属性使用)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务相关组件</category>
      </categories>
  </entry>
  <entry>
    <title>Sentinel</title>
    <url>/2023/08/25/Sentinel/</url>
    <content><![CDATA[<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><h2 id="nacos-dubbo-gateway"><a href="#nacos-dubbo-gateway" class="headerlink" title="nacos dubbo gateway"></a>nacos dubbo gateway</h2><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-1.png"></p>
<p>使用者3个组件搭建的微服务架构,加上springboot,能够完成大部分项目核心功能.</p>
<p>需要引入更多的组件,完善架构.比如sentinel和rocketmq</p>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>微服务架构中,切分的服务越多,调用关系就越复杂.</p>
<p>如果在多个服务调用过程中,由于某个服务的实例故障,导致调用失败,延迟,等待,重试.</p>
<p><strong>需要不需要对这种调用失败的问题进行处理,如果不处理会不会有重大影响?</strong></p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230823140641362.png" alt="image-20230823140641362" style="zoom:50%;" />

<p>如果不及时解决这个问题,会导致A服务中所有服务实例,访问B服务这个宕机故障节点等待排队,压力向上传递了,积累到一定程度,A服务也会有不可访问的危险.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230823141350812.png" alt="image-20230823141350812" style="zoom:50%;" />

<p>最终A作为调用者,瘫痪,整个服务调用链路压力上传,全部瘫痪.</p>
<p>引入熔断机制和支持熔断的技术组件—sentinel</p>
<ul>
<li>熔断</li>
</ul>
<p>牺牲局部保存全局的处理问题的思想(<strong>保险丝</strong>)</p>
<p>在系统中定义远程调用,定义访问方法的资源(sentinel).</p>
<p>提供一个<strong>断路器</strong>. 在调用这个资源的时候,插入一个断路器,利用规则限制,资源一旦发生问题(异常,超时条件),断路器就会开始工作.在三个状态之间进行切换.</p>
<p>闭合,打开,半开</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-2.png" style="zoom:50%;" />

<p>闭合: 正常调用资源的时候</p>
<p>打开: 调用资源的时候微服务断路器判断规则</p>
<p>半开: 打开一段时间之后,尝试半开,半开调用成功,切换回闭合,半开尝试不成功,切换回打开.</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>服务器运行,每个服务器无论硬件还是软件都是承受访问并发的上限.</p>
<p>目的: 限流的目的,防止服务接收超过上限的<strong>请求</strong>,导致崩溃.</p>
<p>考虑服务器性能,软件的性能(通用经验)</p>
<p>例如: </p>
<p>4C8G服务器运行一个tomcat的web应用,承受的并发100左右,占用的cpu线程数30-50之间. <strong>tomcat访问上限的.</strong></p>
<p>流量计算的一些概念和公式;</p>
<ul>
<li>RT: reaction time 表示一次请求服务器处理时长<ul>
<li>服务单独运行,做查询,而且从redis获取数据 响应RT不会太大 10ms以内</li>
<li>连接了数据库mysql软件20ms以上(上限取决于mysql读写数据的速度,数据优化,一般而言 100ms)</li>
<li>服务运行涉及到调用其他服务(单独计算)</li>
</ul>
</li>
<li>QPS: queries per second 每秒请求次数<ul>
<li>理论计算公式: 服务进程 <strong>QPS&#x3D;并发&#x2F;RT</strong></li>
</ul>
</li>
<li>并发: 硬件服务器条件是基础,支持软件同时处理的请求数量 tomcat 一般100并发</li>
<li>pv量: 一般关注的是日pv量 (page view) ,每次请求都是一次pv</li>
</ul>
<p>对于pv量概念,需要了解一个计算思路.</p>
<p><strong>一个系统日pv量20亿. 请估算峰值QPS</strong></p>
<p>满足pv 2&#x2F;8分布的情况.  20% 时间 集中了80%pv</p>
<p>20亿*80%&#x3D;16亿</p>
<p>24*20%&#x3D;4.8小时    17280秒</p>
<p>峰值QPS 16亿&#x2F;17280S&#x3D; 9万&#x2F;S</p>
<p>结论:</p>
<p>掌握内容</p>
<p>给你并发数 假设200 如果达到1000的qps rt是多少? 200ms.</p>
<p>给你并发数 假设200 如果预估rt时间是100ms 每个tomcat qps <strong>2000&#x2F;S</strong></p>
<p>系统日pv量是5亿   峰值qps 估算值<strong>2.25万&#x2F;S</strong>  需要13个tomcat </p>
<p>4C8G 预留系统的占用内存1.5G 够了 20% 浮动 1.5G 其余的全部跑 256M tomcat</p>
<p>2台跑 一台 10个</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>无论是熔断 还是限流 ,总会有一些请求是无法处理的.</p>
<p>降级思路: 发生无法访问的情况,返回一个退而求其次的结果或者数据.</p>
<p><strong>也是微服务分布式集群中 实现系统基本可用的最重要的思路之一</strong></p>
<p>例子: </p>
<p>抖音刷视频的时候,并发持续的高. 但是功能访问分为核心功能和辅助功能.</p>
<p>一定要通过降级保证核心功能可用性.</p>
<p>刷视频,经常看不到评论.</p>
<h1 id="sentinel组件学习"><a href="#sentinel组件学习" class="headerlink" title="sentinel组件学习"></a>sentinel组件学习</h1><h2 id="sentinel介绍"><a href="#sentinel介绍" class="headerlink" title="sentinel介绍"></a>sentinel介绍</h2><p>官网: <a href="http://sentinelguard.io/zh-cn/docs/introduction.html">http://sentinelguard.io/zh-cn/docs/introduction.html</a></p>
<p><strong>注意</strong>: 和redis的sentinel 同名的,但是完全不相关技能技术组件.</p>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的<strong>流量治理组件</strong>，主要以流量为切入点，从流量路由、<strong>流量控制</strong>、流量整形、<strong>熔断降级</strong>、系统自适应过载保护、热点流量防护等多个维度来帮助开发者<strong>保障微服务的稳定性</strong>。</p>
<h2 id="sentinel核心概念"><a href="#sentinel核心概念" class="headerlink" title="sentinel核心概念"></a>sentinel核心概念</h2><p><strong>资源</strong></p>
<p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p>
<p><strong>规则</strong></p>
<p>围绕资源的实时状态设定的规则，可以包括<strong>流量控制规则</strong>、<strong>熔断降级规则</strong>以及系统保护规则。所有规则可以动态实时调整</p>
<h2 id="准备一个测试工程"><a href="#准备一个测试工程" class="headerlink" title="准备一个测试工程"></a>准备一个测试工程</h2><ul>
<li>创建工程</li>
</ul>
<p>后续还有迭代案例 sentinel02 sentinel03</p>
<ul>
<li>父工程添加依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springboot web--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在子工程编写测试基础代码</li>
</ul>
<p>HelloController-HelloService流程</p>
<p>接口文件:</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>请求地址</td>
<td>&#x2F;hello</td>
<td></td>
</tr>
<tr>
<td>请求方式</td>
<td>get</td>
<td></td>
</tr>
<tr>
<td>请求参数</td>
<td>String name</td>
<td>name&#x3D;wang</td>
</tr>
<tr>
<td>返回数据</td>
<td>String result</td>
<td>hi wang</td>
</tr>
</tbody></table>
<h2 id="定义sentinel的资源"><a href="#定义sentinel的资源" class="headerlink" title="定义sentinel的资源"></a>定义sentinel的资源</h2><p>在代码片段中可以引入sentinel 硬编码方式,定义自定义的资源.</p>
<p>HelloController 定义资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.sentinel.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.sentinel.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">//准备一个资源的入口 Entry 资源用完了要释放</span></span><br><span class="line">        Entry entry=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对于资源的调用取决于 entry赋值是否能通过规则的检测</span></span><br><span class="line">            <span class="comment">//如果SphU.entry方法检查 sayHi资源没有违反任何规则 如果违反了</span></span><br><span class="line">            <span class="comment">//就抛出异常,没有违反,就执行向后继续</span></span><br><span class="line">            entry= SphU.entry(<span class="string">&quot;sayHi&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> helloService.sayHi(name);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            <span class="comment">//打印个日志</span></span><br><span class="line">            log.info(<span class="string">&quot;当前资源sayHi收到了限制&quot;</span>,e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (entry!=<span class="literal">null</span>) entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为上述定义的资源准备规则"><a href="#为上述定义的资源准备规则" class="headerlink" title="为上述定义的资源准备规则"></a>为上述定义的资源准备规则</h2><p>可以设置限流规则,可以设置熔断规则.</p>
<p>入门规则: 限流规则</p>
<p>只要现在的项目 启动加载的时候 有Fule的集合.就可以启动规则.</p>
<p>启动类中,定义固定的规则.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SentinelDemo01.class,args);</span><br><span class="line">        <span class="comment">//定义一个限流规则.</span></span><br><span class="line">        List&lt;FlowRule&gt; flowRules=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        FlowRule flowRule=<span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">        <span class="comment">//填写规则的具体属性</span></span><br><span class="line">        <span class="comment">//明确这个规则限制和检查的资源是谁</span></span><br><span class="line">        flowRule.setRefResource(<span class="string">&quot;sayHi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置 流控方式 qps=1 并发=0</span></span><br><span class="line">        flowRule.setGrade(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//限流的阈值 count</span></span><br><span class="line">        flowRule.setCount(<span class="number">1</span>);</span><br><span class="line">        flowRules.add(flowRule);</span><br><span class="line">        <span class="comment">//sentinel组件 加载定义的规则</span></span><br><span class="line">        FlowRuleManager.loadRules(flowRules);</span><br><span class="line">        <span class="comment">//目前规则 定义的意思 : 访问sayHi qps超过阈值1 就会限制流量,不让访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sentinel资源限流的原理流程"><a href="#sentinel资源限流的原理流程" class="headerlink" title="sentinel资源限流的原理流程"></a>sentinel资源限流的原理流程</h2><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230823172618400.png" alt="image-20230823172618400" style="zoom:50%;" />

<p>定义的每一个entry 在调用过程中要经过一批Slot类计算</p>
<p>其中必定经过 三个基础Slot Node Cluster Statistic 然后在经过的slot取决于我们定义的规则由多少种,每种规则由多少个.</p>
<p>根据基本的Slot类计算的统计的结果,判断某个规则Slot是否触发了阈值.如果触发,就直接抛出异常,所有Slot都走完没有违反任何一个,正常调用目标方法或者代码.</p>
<h1 id="SENTINEL熔断限流"><a href="#SENTINEL熔断限流" class="headerlink" title="SENTINEL熔断限流"></a>SENTINEL熔断限流</h1><h2 id="规则文件定义"><a href="#规则文件定义" class="headerlink" title="规则文件定义"></a>规则文件定义</h2><p>资源定义的很多,规则也很多.当前读取规则的方式,不灵活,不能动态读取.</p>
<p>Sentinel提供了一种本地读取规则文件的加载方式.</p>
<ul>
<li>定义规则文件 放到当前项目 JSON格式</li>
<li>项目中利用SPI的方式读取文件并且加载</li>
<li>启动项目利用上述流程加载完整资源和<strong>规则</strong></li>
</ul>
<h2 id="本地文件规则案例"><a href="#本地文件规则案例" class="headerlink" title="本地文件规则案例"></a>本地文件规则案例</h2><h3 id="准备一个和-sentinel01完全一样的web应用"><a href="#准备一个和-sentinel01完全一样的web应用" class="headerlink" title="准备一个和 sentinel01完全一样的web应用"></a>准备一个和 sentinel01完全一样的web应用</h3><p>包含HelloController和HelloService所有功能</p>
<ul>
<li>创建module保证父子继承正确</li>
<li>修改启动类SentinelDemo01–&gt;SentinelDemo02</li>
<li>规则定义和加载的代码彻底删除(换一种加载规则的方式)</li>
</ul>
<h3 id="编写一个本地规则文件"><a href="#编写一个本地规则文件" class="headerlink" title="编写一个本地规则文件"></a>编写一个本地规则文件</h3><p>JSON格式的文本文件 flowRules.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sayHi&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>文件放到当前项目resources文件夹.</p>
<h3 id="创建读取文件的Init类"><a href="#创建读取文件的Init类" class="headerlink" title="创建读取文件的Init类"></a>创建读取文件的Init类</h3><p>对于Sentinel来讲,如果不是在硬编码中直接编辑List&lt;Rule&gt;规则数据.</p>
<p>从任意其它位置读取文件,数据组织的规则对象,都叫做规则数据源DataSource.</p>
<p>LocalDataSourceInit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.sentinel.datasource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.Converter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.FileRefreshableDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.ReadableDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.init.InitFunc;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.degrade.DegradeRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sentinel提供的接口</span></span><br><span class="line"><span class="comment"> * 实现并不是sentinel实现的(符合SPI思路)</span></span><br><span class="line"><span class="comment"> * 最终加载 告诉sentinel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDataSourceInit</span> <span class="keyword">implements</span> <span class="title class_">InitFunc</span> &#123;</span><br><span class="line">    <span class="comment">//初始化加载规则文件的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.读取文件,获取文件名称,类加载器的api</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> LocalDataSourceInit.class.getClassLoader();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">resource</span> <span class="operator">=</span> classLoader.getResource(<span class="string">&quot;flowRules.json&quot;</span>);</span><br><span class="line">        String fileAllName=resource.getFile();</span><br><span class="line">        <span class="comment">//2.调用sentinel现成,将json格式数据文本转化为List&lt;FlowRule&gt;</span></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; datasource=</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileRefreshableDataSource</span>&lt;List&lt;FlowRule&gt;&gt;</span><br><span class="line">                    (fileAllName, <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@param</span> json 从文件中读到的文本</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> List&lt;FlowRule&gt; <span class="title function_">convert</span><span class="params">(String json)</span> &#123;</span><br><span class="line">                            <span class="comment">//调用JSON ali的json工具包</span></span><br><span class="line">                            <span class="comment">//将[] 格式json文本转化成list对象</span></span><br><span class="line">                            <span class="keyword">return</span> JSON.parseArray(json,FlowRule.class);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        <span class="comment">//如果有第二个文件 读取文件全名称 新建第二个datasource</span></span><br><span class="line">        <span class="comment">//3.FlowRuleManager将数据源注册</span></span><br><span class="line">        FlowRuleManager.register2Property(datasource.getProperty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置SPI读取加载方式"><a href="#配置SPI读取加载方式" class="headerlink" title="配置SPI读取加载方式"></a>配置SPI读取加载方式</h3><ul>
<li>准备一个文件夹 resources&#x2F;<strong>META-INF&#x2F;services</strong></li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824101644612.png" alt="image-20230824101644612" style="zoom:50%;" />

<ul>
<li>准备一个由固定名称文件,接口的全路径名称</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">com.alibaba.csp.sentinel.init.InitFunc</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824101834655.png" alt="image-20230824101834655" style="zoom:50%;" />

<ul>
<li>填写内容,InitFunc本地实现类的全路径名称</li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824102025317.png" alt="image-20230824102025317" style="zoom:50%;" />

<ul>
<li>日志打桩验证</li>
</ul>
<p>配置过程中,很多细节如果不正确,你自定义的datasource无效,可以通过日志判断是否加载</p>
<h3 id="验证刷新"><a href="#验证刷新" class="headerlink" title="验证刷新"></a>验证刷新</h3><p>修改流控规则文件中的内容</p>
<p>观察尝试,是否能够动态的调整规则.</p>
<p>答案: 目前无法做到动态刷新规则</p>
<h2 id="利用nacos实现规则的远程读取"><a href="#利用nacos实现规则的远程读取" class="headerlink" title="利用nacos实现规则的远程读取"></a>利用nacos实现规则的远程读取</h2><p>nacos作为配置中心,本来就可以远程管理大量的文本数据 格式包含json格式.</p>
<p>sentinel支持一种数据源叫做NacosDatasource 从指定nacos配置中心读取远程配置文件. nacos可以在文件刷新,新发布之后,触发refresh ,将新数据推送给sentinel实现动态的规则调整.</p>
<p>只有sentinel版本高于1.4才可以实现这个功能. 低于1.4无法读取nacos远程文件.</p>
<h3 id="启动nacos-准备好了远程规则文件"><a href="#启动nacos-准备好了远程规则文件" class="headerlink" title="启动nacos 准备好了远程规则文件"></a>启动nacos 准备好了远程规则文件</h3><p>public命名空间 准备一个DEFAULT_GROUP分组的配置文件 flowRules.json</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-3.png" style="zoom:50%;" />

<h3 id="准备一个新项目的案例sentinel03"><a href="#准备一个新项目的案例sentinel03" class="headerlink" title="准备一个新项目的案例sentinel03"></a>准备一个新项目的案例sentinel03</h3><ul>
<li>保留HelloController HelloService</li>
<li>不保留本地文件规则读取方式</li>
</ul>
<h3 id="添加一个支持sentine读取nacos文件依赖"><a href="#添加一个支持sentine读取nacos文件依赖" class="headerlink" title="添加一个支持sentine读取nacos文件依赖"></a>添加一个支持sentine读取nacos文件依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--支持sentinel读取nacos的文件依赖资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="yaml配置"><a href="#yaml配置" class="headerlink" title="yaml配置"></a>yaml配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># 一个文件 就是一个datasource</span></span><br><span class="line">      <span class="comment"># 一个文件内容中的规则必须是同一种</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="comment"># 每一个key值代表的都是一个数据源</span></span><br><span class="line">        <span class="attr">nacosFlowRule:</span></span><br><span class="line">          <span class="comment"># 数据源类型 file nacos db</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="comment"># 连接</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="comment"># public DEFALSE_GROUP group  namespace省略</span></span><br><span class="line">            <span class="comment"># data-type: 默认json</span></span><br><span class="line">            <span class="comment"># 读取远程文件名称</span></span><br><span class="line">            <span class="attr">data-id:</span> <span class="string">flowRules.json</span></span><br><span class="line">            <span class="comment"># 必须配置 指定的规则类型</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line">            <span class="comment"># sentinel 1.7以后 必须配置nacos授权用户名密码</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure>

<h3 id="启动测试动态规则"><a href="#启动测试动态规则" class="headerlink" title="启动测试动态规则"></a>启动测试动态规则</h3><p>初始化规则 qps&gt;1 限流</p>
<p>修改规则 qps&gt;1000 限流</p>
<h3 id="sentinel控制台"><a href="#sentinel控制台" class="headerlink" title="sentinel控制台"></a>sentinel控制台</h3><p>使用控制台好处是视图感受更强</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824111933369.png" alt="image-20230824111933369" style="zoom: 50%;" />

<p>上述图标内容,配置的就是一个限流规则</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span><span class="string">&quot;someResource&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span><span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="注解实现资源的定义"><a href="#注解实现资源的定义" class="headerlink" title="注解实现资源的定义"></a>注解实现资源的定义</h2><p>sentinel 通过硬编码 定义资源 侵入性比较强,代码内聚不高的特点.</p>
<p>所以sentinel整合spring aop切面实现了注解的使用.</p>
<h3 id="注解定义资源案例"><a href="#注解定义资源案例" class="headerlink" title="注解定义资源案例"></a>注解定义资源案例</h3><p>sentinel03基础之上,把硬编码的方式,改成注解的方式.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-4.png" style="zoom:50%;" />

<h3 id="注解的使用原理"><a href="#注解的使用原理" class="headerlink" title="注解的使用原理"></a>注解的使用原理</h3><p>底层原理: AOP实现的资源定义</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824113824597.png" alt="image-20230824113824597" style="zoom:50%;" />

<p>切面目前没有处理异常捕获逻辑的.所以一旦出现流控限制,抛异常</p>
<p>需要在注解@SentinelResource中提供更多的属性.</p>
<p>准备好和blockHandler名称相同的一个方法,参数和返回值和目标方法一致,<strong>同时</strong>,要接收一个BlockException类型异常对象.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-5.png" style="zoom:50%;" />

<ul>
<li>blockHandler属性: 值是一个字符串,表示的含义是当前目标类的一个方法名称.</li>
</ul>
<p>这个属性的定义会在切面中生成异常处理的逻辑.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824114308850.png" alt="image-20230824114308850" style="zoom:50%;" />

<h3 id="使用注解SentinelResource定义controller方法为资源"><a href="#使用注解SentinelResource定义controller方法为资源" class="headerlink" title="使用注解SentinelResource定义controller方法为资源"></a>使用注解SentinelResource定义controller方法为资源</h3><ul>
<li>在Controller的方法sayHi 添加一个注解</li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-6.png" style="zoom:50%;" />

<ul>
<li>给新的资源增加一个流控规则</li>
</ul>
<p>修改nacos中flowRules.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sayHi&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sayHello&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="SentinelResource注解的其它属性"><a href="#SentinelResource注解的其它属性" class="headerlink" title="SentinelResource注解的其它属性"></a>SentinelResource注解的其它属性</h3><ul>
<li>value: 定义资源的名称 SphU.entry(“${value}”)</li>
<li>blockHandler: 处理资源进入之后 违反规则抛出的BolckException异常使用的方法名字. 默认情况下需要在资源方法所在的类创建这个方法,但是也可以配合blockHandlerClass,定义一个<strong>静态</strong>方法调用. </li>
<li>blockHandlerClass: 指定调用抛出BlockException异常的处理方法,方法必须静态.</li>
</ul>
<p>HelloBlockHandler.blockHandler().</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824140353094.png" alt="image-20230824140353094" style="zoom:50%;" />

<ul>
<li>fallback: 作用是定义处理Throwable异常的方法 和blockHandler唯一区别是对应异常类型Throwable.</li>
<li>fallbackClass: 作用是定义调用fallback方法的类. 可以和blockHandlerClass同一个.</li>
</ul>
<p><strong>注意的点</strong>:</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway-7.png" style="zoom:50%;" />



<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824142736961.png" alt="image-20230824142736961" style="zoom:50%;" />

<p>在controller中定义了一个方法作为资源管理</p>
<p>并且在nacos配置了test资源的限流规则(一次都不让访问,访问一次就抛BlockException)</p>
<p>访问接口: </p>
<p><a href="http://localhost:8080/hello?name=%E7%8E%8B">http://localhost:8080/hello?name=王</a>  结果是什么</p>
<ol>
<li>进入sayHi资源的 Block降级</li>
<li>进入sayHi资源的fallback降级</li>
<li>进入test资源的fallback降级</li>
<li><ul>
<li><input checked="" disabled="" type="checkbox"> 正常调用</li>
</ul>
</li>
</ol>
<p><strong>结论不能使用this调用定义了资源的方法.</strong></p>
<h2 id="规则详解"><a href="#规则详解" class="headerlink" title="规则详解"></a>规则详解</h2><p>sentinel提供了丰富的规则种类,详细介绍 使用json配置的规则由哪些属性.</p>
<h3 id="限流规则"><a href="#限流规则" class="headerlink" title="限流规则"></a>限流规则</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span><span class="string">&quot;app&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span><span class="string">&quot;limitApp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span><span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>resource: 绑定已经定义好的资源名称</p>
</li>
<li><p>count: 限流阈值,至于阈值表示的何种含义 取决于grade grade&#x3D;1 qps数量 grade&#x3D;0 并发数量(web应用并发表示同时存在请求个数)</p>
</li>
<li><p>grade: </p>
<p>1 qps 流控类型</p>
<p>0 并发 流控类型</p>
</li>
<li><p>strategry: 限流的模式</p>
<p>0 直接限流: 针对resource的资源做限流</p>
<p>1 关联限流, limitApp 属性值也表示一个资源,如果app的资源访问超过阈值了,限制limitApp.</p>
<p>例如: 双11,所有资源都需要给下单让路.</p>
<p>2 链路 limitApp 指定的资源,查看当前资源的链路是否是通过limitApp进入的,如果不是,不限制流量,如果是则限制流量.(限制的是来源)</p>
</li>
<li><p>limitApp: 当前资源关联的其它的某个资源,是否生效取决于strategy的值 1 2有用,而且作用不同.</p>
</li>
<li><p>controlBehavior:  限流效果,当访问已经违反了限流规则时,表现状态</p>
</li>
</ul>
<p>​		0:  直接拒绝抛异常</p>
<p>​		1: Warm up 慢慢的拒绝抛异常</p>
<p>​		2: 排队 后续请求不拒绝 排队到一个queue队列(有上限)</p>
<h3 id="熔断规则"><a href="#熔断规则" class="headerlink" title="熔断规则"></a>熔断规则</h3><p>示例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sayHiService&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minRequestAmount&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;slowRatioThreshold&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;statIntervalMs&quot;</span><span class="punctuation">:</span> <span class="number">10000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>resource: 绑定已经定义好的资源名称</p>
</li>
<li><p>count: 熔断触发的阈值(不再调用这个资源,而是访问降级策略),如果grade&#x3D;0 count表示慢调用临界RT(响应时间单位毫秒),超过这个数字,就记录一次慢调用.grade是1,count值应该是&gt;0小于1的小数,表示异常比例,grade&#x3D;2 count配置整数,表示异常出现的次数</p>
</li>
<li><p>grade: 熔断类型 0 默认值 慢调用比例 1 异常比例 2异常数</p>
</li>
<li><p>timeWindow: 如果触发熔断,持续时间,单位秒</p>
</li>
<li><p>minRequestAmount: 最少统计请求数量,如果没达到,即使超过count的阈值,也不熔断</p>
</li>
<li><p>slowRatioThreshold: 慢调用比例,只有在grade&#x3D;0的时候才有用.</p>
</li>
<li><p>statIntervalMs: 统计时长,计算判断熔断规则是否违反的逻辑中,有很多都需要统计时间段 单位是毫秒数.</p>
</li>
</ul>
<h3 id="做熔断案例"><a href="#做熔断案例" class="headerlink" title="做熔断案例"></a>做熔断案例</h3><p>需求: 对sayHi资源做熔断案例的测试,使用慢调用比例的类型.</p>
<ul>
<li>准备和定义一个资源(已经有了)</li>
<li>准备和定义一个规则文件</li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230824152826215.png" alt="image-20230824152826215" style="zoom:50%;" />

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sayHi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minRequestAmount&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;slowRatioThreshold&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;statIntervalMs&quot;</span><span class="punctuation">:</span> <span class="number">10000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>上述规则定义加载之后,sentinel会统计针对sayHi资源是否达到熔断阈值要求,从而将sayHi屏蔽.屏蔽时长10秒钟(底层断路器Slot计算的打开 关闭 半开),10秒中之后尝试访问资源,如果再次出现慢调用,将会继续屏蔽.屏蔽的结果就是资源访问抛出DegradException.</p>
<p>条件:</p>
<ol>
<li>10秒之内的统计数据</li>
<li>最小请求数量达到1</li>
<li>记录的慢调用次数&#x2F;总调用次数&gt;0.5</li>
</ol>
<ul>
<li>配置sentinel的nacos数据源加载这个新文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># 一个文件 就是一个datasource</span></span><br><span class="line">      <span class="comment"># 一个文件内容中的规则必须是同一种</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">nacosDegradeRule:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">data-id:</span> <span class="string">degradeRules.json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">degrade</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure>



<p>尝试另一个熔断规则</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sayHi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minRequestAmount&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;slowRatioThreshold&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;statIntervalMs&quot;</span><span class="punctuation">:</span> <span class="number">10000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>10秒钟之内,访问次数达到1,并且异常数达到5,就熔断抛异常,持续10秒钟</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/sentinel%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81.png" alt="sentinel熔断限流"></p>
]]></content>
      <categories>
        <category>微服务相关组件</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置</title>
    <url>/2023/08/25/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="SpringBoot-start-自定义配置"><a href="#SpringBoot-start-自定义配置" class="headerlink" title="SpringBoot start 自定义配置"></a>SpringBoot start 自定义配置</h1><h2 id="准备一个项目环境"><a href="#准备一个项目环境" class="headerlink" title="准备一个项目环境"></a>准备一个项目环境</h2><ul>
<li>依赖:<ul>
<li>spring-boot-starter (包含了spring框架的大部分依赖,和springboot自动配置依赖)</li>
<li>junit</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring框架版本迭代历史"><a href="#Spring框架版本迭代历史" class="headerlink" title="Spring框架版本迭代历史"></a>Spring框架版本迭代历史</h2><ul>
<li>SPRING1.X 时代</li>
</ul>
<p>大量编写xml配置文件的节点,spring框架开发应用程序,每个xml中都会使用大量bean标签,来实现</p>
<p>SPRING容器的IOC DI功能.<strong>不存在注解</strong> @Autowired @Component @Service @Controller@Repository</p>
<ul>
<li>SPRING2.X时代</li>
</ul>
<p>java出现了jdk1.5,新特性<strong>注解</strong>,<strong>反射</strong>,枚举等功能.SPRING随之推出了基于java5的注解功能的新特性,IOC容器的注解,使得扫描注解能够构造bean对象,@Component @Service @Controller @Repository DI注入@Qualifier @Autowired.让在1.x时代编写大量的xml配置文件的工作减少了很多很多.</p>
<p>什么情况下使用注解:业务层使用注解(Controller Service)</p>
<p>什么情况下使用xml配置:引入的技术 redis,mysql,等使用xml配置</p>
<ul>
<li><strong>SPRING3.X****时代</strong></li>
</ul>
<p>基于java5的注解功能上,spring扩展了大量的功能注解,比如@Configuration @Bean </p>
<p>@ComponentScan等等,他们可以让在2.x时代残留的那种xml配置,彻底的消失了,从xml配置完全转化成为代码注解的编写;</p>
<p>趋势: <strong>配置越来越简单</strong> springboot的出现打下了坚实的基础</p>
<ul>
<li><strong>SPRING4.X</strong>&#x2F;5.X</li>
</ul>
<p>都是在基于这个趋势,实现更多注解的扩展,让代码的功能变得更强,开发的效率变得更高,出现了很多组合注解,@RestController 4.X时代，spring提供了一个叫做<strong>条件注解的</strong> <strong>@Conditional</strong>，springboot能够做到0 xml配置文件是</p>
<p>springboot功劳吗?本质不是,spring就支持不需要配置文件xml了.</p>
<h2 id="理解注解的基本功能"><a href="#理解注解的基本功能" class="headerlink" title="理解注解的基本功能"></a>理解注解的基本功能</h2><h3 id="SPRING-3-X注解"><a href="#SPRING-3-X注解" class="headerlink" title="SPRING 3.X注解"></a>SPRING 3.X注解</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>这个注解,是在Spring 3.x出现的一个核心的<strong>元数据</strong>注解,配置类就是元数据(spring应用程序在加载运行之前,必须要读取所有配置类才能正常运转).</p>
<p>表示的是一个配置类,spring可以加载这种配置类,就像早期加载一个xml一样.</p>
<ul>
<li>案例读取xml</li>
</ul>
<p><strong>第一步</strong>: 准备一个xml文件</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821104632991.png" alt="image-20230821104632991" style="zoom: 33%;" />

<p><strong>第二步</strong>: 代码中准备一个业务类Bean01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean01</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;容器加载了bean01对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>: 测试类启动spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行测试单元</span></span><br><span class="line"><span class="comment"> * 测试入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载xml启动spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadXml</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//spring给我提供了加载xml的api</span></span><br><span class="line">        ClassPathXmlApplicationContext</span><br><span class="line">                context=</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;demo01.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置类 启动spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例读取配置类</li>
</ul>
<p><strong>第一步</strong>: 准备一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为spring容器入口加载的类,不一定必须添加注解</span></span><br><span class="line"><span class="comment"> * 为了标注当前类是配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig01</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: 测试加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.test.config.MyConfig01;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行测试单元</span></span><br><span class="line"><span class="comment"> * 测试入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载xml启动spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadXml</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//spring给我提供了加载xml的api</span></span><br><span class="line">        ClassPathXmlApplicationContext</span><br><span class="line">                context=</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;demo01.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置类 启动spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext</span><br><span class="line">                context=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig01.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>目前测试功能,配置类并没有完全代替xml,因为还缺少Bean01对象的创建.</p>
<p>如果在一个xml中准备加载bean对象,需要用到bean标签,对应在配置类中完成这个功能,需要用@Bean.</p>
<p>作用在一个配置的方法上,可以将方法的返回对象,加载到容器管理成bean.</p>
<p>对象id默认是方法名称.可以使用@Bean注解的属性name自定义id值.</p>
<p>在配置类添加这个注解创建Bean01</p>
<p><strong>第一步</strong>: Bean01添加getter setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean01</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;容器加载了bean01对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: xml提供了初始化属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tarena.luban.test.bean.Bean01&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;王翠花&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>: 配置完成这个功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.test.bean.Bean01;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为spring容器入口加载的类,不一定必须添加注解</span></span><br><span class="line"><span class="comment"> * 为了标注当前类是配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig01</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean01 <span class="title function_">bean01</span><span class="params">()</span>&#123;</span><br><span class="line">        Bean01 bean01=<span class="keyword">new</span> <span class="title class_">Bean01</span>();</span><br><span class="line">        bean01.setAge(<span class="string">&quot;19&quot;</span>);</span><br><span class="line">        bean01.setName(<span class="string">&quot;刘首付&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步</strong>: 启动运行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行测试单元</span></span><br><span class="line"><span class="comment"> * 测试入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载xml启动spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadXml</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//spring给我提供了加载xml的api</span></span><br><span class="line">        ClassPathXmlApplicationContext</span><br><span class="line">                context=</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;demo01.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//拿一下容器bean对象</span></span><br><span class="line">        <span class="type">Bean01</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Bean01.class);</span><br><span class="line">        System.out.println(bean.getAge());</span><br><span class="line">        System.out.println(bean.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置类 启动spring容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext</span><br><span class="line">                context=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig01.class);</span><br><span class="line">        <span class="type">Bean01</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Bean01.class);</span><br><span class="line">        System.out.println(bean.getAge());</span><br><span class="line">        System.out.println(bean.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>spring 3.0 出现的,功能是配合一个配置类,扫描当前系统自定义的业务bean对象(@ Component,@Controller,@Repository,@Autowired,@Configuration…).</p>
<p>使用这个注解的时候提供一个basePackages的String[] 数据,定义扫描包范围.</p>
<p>不给指定,默认是当前配置类所在的包就是扫描范围.</p>
<ul>
<li>xml配置方式</li>
</ul>
<p><strong>第一步</strong>： 准备一个被扫描的bean对象 Bean02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean02</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;容器加载了bean02对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>：修改xml 扫描包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tarena.luban.test.bean.Bean01&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;王翠花&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果在配置xml的文件中 扫描包需要用到标签component-scan--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tarena.luban.test.bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置类配置方式</li>
</ul>
<p>修改配置类,添加当前扫描注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.test.bean.Bean01;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为spring容器入口加载的类,不一定必须添加注解</span></span><br><span class="line"><span class="comment"> * 为了标注当前类是配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages =&#123;&quot;com.tarena.luban.test.bean&quot;&#125; )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig01</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean01 <span class="title function_">bean01</span><span class="params">()</span>&#123;</span><br><span class="line">        Bean01 bean01=<span class="keyword">new</span> <span class="title class_">Bean01</span>();</span><br><span class="line">        bean01.setAge(<span class="string">&quot;19&quot;</span>);</span><br><span class="line">        bean01.setName(<span class="string">&quot;刘首付&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>对应的是xml配置的import标签.</p>
<p>spring容器,一般情况下只允许加载一个xml配置文件,或者一个配置类.</p>
<p>如果所有配置逻辑在这一个文件或类中完成.文件或者类内容 冗长,不易读.</p>
<p>spring允许将不同配置逻辑放到不同xml或者配置类中的.</p>
<p>可以使用import进行导入.</p>
<ul>
<li>xml配置案例</li>
</ul>
<p><strong>第一步</strong>: 准备测试的Bean03(Bean02拷贝)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean03</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;容器加载了bean03对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: demo02.xml 额外的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tarena.luban.test.bean.Bean03&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>: 入口配置文件demo01.xml导入demo02.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tarena.luban.test.bean.Bean01&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;王翠花&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果在配置xml的文件中 扫描包需要用到标签component-scan--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tarena.luban.test.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;demo02.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置类案例</li>
</ul>
<p><strong>第一步</strong>: 准备一个对标demo02.xml的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.test.bean.Bean03;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig02</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean03 <span class="title function_">bean03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean03</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: 导入配置类的注解@Import使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.test.bean.Bean01;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为spring容器入口加载的类,不一定必须添加注解</span></span><br><span class="line"><span class="comment"> * 为了标注当前类是配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages =&#123;&quot;com.tarena.luban.test.bean&quot;&#125; )</span></span><br><span class="line"><span class="meta">@Import(&#123;MyConfig02.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig01</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean01 <span class="title function_">bean01</span><span class="params">()</span>&#123;</span><br><span class="line">        Bean01 bean01=<span class="keyword">new</span> <span class="title class_">Bean01</span>();</span><br><span class="line">        bean01.setAge(<span class="string">&quot;19&quot;</span>);</span><br><span class="line">        bean01.setName(<span class="string">&quot;刘首付&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>: 如果一个项目中的配置类非常多(100个),入口配置类1个,导入99个.</p>
<p>除了可以直接导入配置类的反射,还可以导入一个配置类的选择器,通过这个选择器selector的方法调用,拿到加载的配置类全路径名称”com.tarena.luban.test.config.MyConfig02”</p>
<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>可以<strong>配合配置类使用</strong>,导入一个外部的properties配置文件.</p>
<p><strong>第一步</strong>: 准备一个配置文件properties</p>
<p>demo.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">csmall.user</span>=<span class="string">abc</span></span><br><span class="line"><span class="attr">csmall.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: 在配置类使用这个注解读取properties文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//从classpath中 读取一个demo.properties配置文件</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;demo.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig02</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean03 <span class="title function_">bean03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean03</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p>虽然配置类可以代替xml使用,但是有的时候,场景环境中,需要同时存在配置类和xml的.所以这个注解可以配合配置类,加载一个外部的xml文件.</p>
<p>案例测试</p>
<p><strong>第一步</strong>: Bean04</p>
<p><strong>第二步</strong>: demo03.xml 加载bean标签,创建Bean04</p>
<p><strong>第三步</strong>: 通过MyConfig01导入demo03.xml</p>
<h4 id="SpringBoot每个版本提供了大量的配置类"><a href="#SpringBoot每个版本提供了大量的配置类" class="headerlink" title="SpringBoot每个版本提供了大量的配置类"></a>SpringBoot每个版本提供了大量的配置类</h4><p>springboot提倡约定大于配置,准备了大量默认配置.</p>
<p>原因 springboot 一堆**AutoConfiguration.</p>
<h3 id="SPRINGBOOT-条件衍生注解"><a href="#SPRINGBOOT-条件衍生注解" class="headerlink" title="SPRINGBOOT 条件衍生注解"></a>SPRINGBOOT 条件衍生注解</h3><p>Spring 4.x 推出一个注解@Conditional 条件注解.</p>
<p>允许我们开发,扩展,使用任何我们自定义的条件逻辑,扩展新的注解.</p>
<p>SpringBoot基础,就是他利用这种注解,衍生了大量的条件注解</p>
<h4 id="ConditionalOnClass-ConditionalOnMissingClass"><a href="#ConditionalOnClass-ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnClass&#x2F;@ConditionalOnMissingClass"></a>@ConditionalOnClass&#x2F;@ConditionalOnMissingClass</h4><p>这两个注解的条件逻辑相反,都是类和方法的注解.如果作用在类上,一般也是配置类.</p>
<p>这两个注解会根据条件属性,判断某个各,某几个指定的类是否存在于当前依赖环境.</p>
<p>存在或不存在是满足条件的前提,如果满足条件,对应的类或者方法才会选择加载或者不加载. <strong>一个配置类中代码是否需要加载由这些条件注解判断</strong>.</p>
<p>案例演示:</p>
<p><strong>第一步</strong>: 准备测试条件注解的配置类  MyConditionConfig01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.tarena.luban.test.bean.Bean05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConditionConfig01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConditionConfig01</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;条件配置类01,满足条件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: 准备配置逻辑 加载Bean05</p>
<p>Bean05代码不重要,只是作为条件存在的</p>
<p><strong>第三步</strong>: 测试条件注解的满足和不满足的场景.</p>
<p>如果指定的Bean05 由于Bean05是存在的类,条件不满足</p>
<p>如果指定的Bean06 由于Bean06是不存在的类,条件满足</p>
<p>结论:</p>
<p>@ConditionalOnMissingClass: 指定类不存在 条件满足,反之不满足.</p>
<p>@ConditionalOnClass: 指定了存在 条件满足,反之不满足</p>
<h4 id="ConditionalOnBean-ConditionalOnMissingBean"><a href="#ConditionalOnBean-ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnBean&#x2F;@ConditionalOnMissingBean"></a>@ConditionalOnBean&#x2F;@ConditionalOnMissingBean</h4><p>结论:</p>
<p>@ConditionalOnBean :  指定某个类的bean对象在容器中存在 ,条件则满足</p>
<p>@ConditionalOnMissingBean: 指定某个类的bean对象在容器中不存在,条件则满足</p>
<p>测试案例:</p>
<p><strong>第一步</strong>: 准备配置类MyConditionConfig02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tarena.luban.test.bean.Bean02;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(value = &#123;Bean02.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConditionConfig02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConditionConfig02</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;条件配置类02,满足条件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h4><p>类和方法的注解,可以根据当前环境变量(各种yaml properties属性)</p>
<p>判断最终条件是否满足</p>
<p>测试案例</p>
<p><strong>第一步</strong>: MyConditionConfig03</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.test.config.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prefix 定义属性前缀</span></span><br><span class="line"><span class="comment"> * value/name 只能存在一个 都表示属性名</span></span><br><span class="line"><span class="comment"> * havingValue 是否存在和等于</span></span><br><span class="line"><span class="comment"> * matchIfMissing true和false  如果当前环境没这个属性 条件满足还是不满足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">        prefix = &quot;csmall&quot;,</span></span><br><span class="line"><span class="meta">        name=&#123;&quot;password&quot;&#125;,</span></span><br><span class="line"><span class="meta">        havingValue = &quot;123456&quot;,</span></span><br><span class="line"><span class="meta">        matchIfMissing = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConditionConfig03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConditionConfig03</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;条件配置类03,满足条件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他条件注解"><a href="#其他条件注解" class="headerlink" title="其他条件注解"></a>其他条件注解</h4><p>以下注解全部都是就@ConditionalOn开始的</p>
<ul>
<li>Java: 条件取决于判断java版本</li>
<li>WebApplication: 取决于是不是web应用,是则满足</li>
<li>NotWebApplicaiton: 不是则满足</li>
<li>Resource: 取决于判断是否读取到对应资源</li>
<li>SingleCandidate: 指定某个类是否只有一个bean对象</li>
<li>…</li>
</ul>
<h2 id="Springboot自动配置逻辑"><a href="#Springboot自动配置逻辑" class="headerlink" title="Springboot自动配置逻辑"></a>Springboot自动配置逻辑</h2><h3 id="启动类核心注解"><a href="#启动类核心注解" class="headerlink" title="启动类核心注解"></a>启动类核心注解</h3><p>@SpringBootApplication </p>
<p>组合了三个注解</p>
<p>@SpringBootConfiguration: 标识一个类是配置类. 启动类就是入口的配置类</p>
<p>@ComponentScan :  配合配置类使用@Configuration 默认扫描当前配置类所在包.</p>
<p>如果我们不在启动类上 重新扫描,默认扫描的就是启动类的包.</p>
<p>@EnableAutoConfiguration: </p>
<p><strong>原则: 但凡叫做@Enable</strong>的注解,必定在做的事情一定Import**</p>
<p>导入的是一个选择器 ****Selector</p>
<ul>
<li>阅读选择器内容</li>
</ul>
<p>Selector核心方法返回值 String[]&#x2F;List&lt;String&gt;,数组的值,包含当前版本springboot,当前环境中所有的**AutoConfiguration 全路径名称.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AutoConfigurationImportSelector</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821153430307.png" alt="image-20230821153430307"></p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821153634893.png" alt="image-20230821153634893"></p>
<p>其中自动配置类如果包名是org.springframework.boot 就是当前版本springboot自带的自动配置,如果不是,引入的第三方依赖 自定义的starter</p>
<ul>
<li>是否全部加载</li>
</ul>
<p>绝大部分的自动配置类 springboot当前环境都不会满足条件,所以不会直接加载.</p>
<p>如果我们想要看看当前springboot环境到底满足哪些配置,不满足哪些配置类.</p>
<p>项目配置文件application.yaml配置日志root级别debug</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span> </span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h3 id="自动配置逻辑思路总结"><a href="#自动配置逻辑思路总结" class="headerlink" title="自动配置逻辑思路总结"></a>自动配置逻辑思路总结</h3><ul>
<li>springboot自动配置逻辑基础是什么:<ul>
<li>spring提供的大量注解发展</li>
</ul>
</li>
<li>自动配置加载的流程是什么:<ul>
<li><ol>
<li>核心注解开始</li>
<li>导入选择器: 当前环境所有autoConfiguration都加载</li>
<li>每一个AutoConfiguration都具备条件注解,满足的才加载(约定大于配置)</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="自定义-starter"><a href="#自定义-starter" class="headerlink" title="自定义 starter"></a>自定义 starter</h2><h3 id="spring-boot-SPI-读取自动配置类方式"><a href="#spring-boot-SPI-读取自动配置类方式" class="headerlink" title="spring boot SPI 读取自动配置类方式"></a>spring boot SPI 读取自动配置类方式</h3><p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821161933830.png" alt="image-20230821161933830"></p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821161952639.png" alt="image-20230821161952639"></p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230821162012195.png" alt="image-20230821162012195"></p>
<ul>
<li>第三方依赖 **-spring-boot-starter(至少具备spring-boot-starter)</li>
<li>准备一个SPI的文件 resources&#x2F;META-INF&#x2F;spring.factories</li>
<li>文件中编辑内容 格式</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">第三方提供的自动配置类全路径名称</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编写配置类,配置条件注解</li>
</ul>
<p>项目一旦依赖starter,就会结合springboot那些自动配置类 读取自定义starter的**AutoConfiguration</p>
<ul>
<li>UserAutoConfiguraiton配置逻辑</li>
</ul>
<p>需求: 配置类会跟随依赖luban-demo-spring-boot-starter在其它项目中自动加载,但是提供一个加载的条件.</p>
<p><strong>项目环境里必须存在一个属性 user.enable 值必须是 true 才满足</strong>UserAutoConfiguration的条件.条件一旦满足 创建User的bean对象.</p>
<p>详细代码,请参考luban-demo-spring-boot-starter案例</p>
<h3 id="spring-boot-starter"><a href="#spring-boot-starter" class="headerlink" title="**-spring-boot-starter"></a>**-spring-boot-starter</h3><p>这种自动配置的项目,一般都是提供给第三方使用的.</p>
<p>比如 A公司的**-spring-boot-starter 开源出去,所有其它公司依赖,只要满足条件,就可以使用A公司编写的自动配置逻辑.</p>
<h2 id="属性读取的注解"><a href="#属性读取的注解" class="headerlink" title="属性读取的注解"></a>属性读取的注解</h2><p>背景: **-spring-boot-starter 第三方依赖的自动配置.内部有第三方提供的一些配置bean对象,但是我们不能直接修改初始化bean对象的属性,starter包中也不会随便定义初始化属性.</p>
<p>比如 RedisTemplate 可能有默认的连接redis属性 localhost:6379.</p>
<p>如果我想修改,一般都是通过yaml属性修改.</p>
<p>涉及到包中自动配置bean对象属性赋值的逻辑.</p>
<p><strong>@ConfigurationProperties</strong></p>
<p>类注解,作用到一个单独读取属性的类上**Properties.</p>
<p>例如 nacos mybatis dubbo redis es.. yaml自动提示的那些属性</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822090741885.png" alt="image-20230822090741885" style="zoom:50%;" />

<p>如果按照图中的类型,使用这个注解,当前项目yaml文件,properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<p>@Value也可以给属性赋值,为什么要使用@ConfigurationProperties</p>
<p>@Value不能赋值复杂的结构</p>
<p>如果**Properties属性中,存在其他引用类型,@Value就无法赋值了,需要使用@ConfigurationProperties</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822091129272.png" alt="image-20230822091129272" style="zoom:50%;" />

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.sentinel</span></span><br></pre></td></tr></table></figure>

<p>不能直接用&#x3D;号赋值,因为Sentinel是个引用类型</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822091224398.png" alt="image-20230822091224398" style="zoom: 50%;" />

<p>允许复杂结构的赋值</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.sentinel.master</span>=<span class="string">m1</span></span><br><span class="line"><span class="attr">spring.redis.sentinel.nodes[0]</span>=<span class="string">10.0.0.0:26379</span></span><br><span class="line"><span class="attr">spring.redis.sentinel.nodes[1]</span>=<span class="string">10.0.0.0:26380</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">sentinel:</span></span><br><span class="line">			<span class="attr">master:</span> <span class="string">m1</span></span><br><span class="line">			<span class="attr">nodes:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:26379,10.0.0.0:26380</span></span><br></pre></td></tr></table></figure>



<p><strong>@EnableConfigurationProperties</strong></p>
<p>作用在配置类的,将指定的属性类**Properties注册成bean对象在当前配置类使用的.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822092027864.png" alt="image-20230822092027864" style="zoom:50%;" />

<p>多数情况下都可以在当前配置类中直接使用.</p>
]]></content>
      <categories>
        <category>Spring相关</category>
      </categories>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2023/08/05/Spring/</url>
    <content><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="Spring框架的作用"><a href="#Spring框架的作用" class="headerlink" title="Spring框架的作用"></a>Spring框架的作用</h2><p>Spring框架主要解决了创建对象和管理对象的相关问题。</p>
<p>通过Spring创建并管理对象，可以使得开发者不再反复关心对象的创建过程，并且，默认情况下，由Spring创建的对象都是单例的，这是非常有必要的！</p>
<blockquote>
<p>由Spring创建的对象通常称之为Spring Bean。</p>
<p>由于Spring会创建并管理很多对象，所以Spring也通常被称之为Spring容器。</p>
</blockquote>
<h2 id="Spring框架的依赖项"><a href="#Spring框架的依赖项" class="headerlink" title="Spring框架的依赖项"></a>Spring框架的依赖项</h2><p>Spring框架的基础依赖项是：<code>spring-context</code>。</p>
<h2 id="使用Spring框架创建对象"><a href="#使用Spring框架创建对象" class="headerlink" title="使用Spring框架创建对象"></a>使用Spring框架创建对象</h2><h3 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h3><p>在配置类上，添加<code>@ComponentScan</code>注解可以开启组件扫描。</p>
<blockquote>
<p>在Spring Boot项目中，启用类上的<code>@SpringBootApplication</code>注解中包含<code>@ComponentScan</code>。</p>
<p>关于<code>@SpringBootApplication</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">-- <span class="meta">@ComponentScan</span></span><br><span class="line">-- <span class="meta">@SpringBootConfiguration</span></span><br><span class="line">-- -- <span class="meta">@Configuration</span></span><br></pre></td></tr></table></figure>

<p>另外，如果没有在<code>@ComponentScan</code>上配置扫描的包，默认扫描的是当前配置类所在的包。</p>
</blockquote>
<p>在类上添加<code>@Component</code>或基于<code>@Component</code>的组合注解，即可将类标记为组件类。</p>
<blockquote>
<p>在Spring框架中，组件注解有：</p>
<ul>
<li><code>@Component</code></li>
<li><code>@Controller</code></li>
<li><code>@Service</code></li>
<li><code>@Repository</code></li>
<li><code>@Configuration</code></li>
</ul>
<p>在Spring MVC框架中，还新增了组件注解：</p>
<ul>
<li><code>@RestController</code></li>
<li><code>@ControllerAdvice</code></li>
<li><code>@RestControllerAdvice</code></li>
</ul>
</blockquote>
<p>Spring框架在执行组件扫描时，会扫描所配置的包及其子孙包，并尝试创建所有组件类的对象。</p>
<p>这种做法只适用于自定义的类。</p>
<h3 id="Bean方法"><a href="#Bean方法" class="headerlink" title="@Bean方法"></a>@Bean方法</h3><p>在配置类中，可以自行设计方法，返回所需的对象，并在方法上添加<code>@Bean</code>注解，则Spring会自动调用此方法，并管理此方法返回的对象。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserController <span class="title function_">userController</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法适用于所有类型创建对象，但一般用于创建非自定义类的对象。</p>
<h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>默认情况下，被Spring管理的对象都是单例的，也可以通过<code>@Scope(&quot;prototype&quot;)</code>修改为非单例的（相当于局部变量）。</p>
<p>被Spring管理的单例的Spring Bean，默认情况下，都是预加载的（相当于饿汉式的单例模式），也可以通过<code>@Lazy</code>注解修改为懒加载的（相当于懒汉式的单例模式）。</p>
<p>注意：不要把Spring和单例模式这种设计模式直接划等号，只是Spring管理的对象的特征与单例模式的相同而已。</p>
<p>如果使用组件扫描的方式创建对象，则在类上添加<code>@Scope</code>或<code>@Lazy</code>来配置作用域，如果使用<code>@Bean</code>方法的方式创建对象，则在方法上添加这些注解来配置作用域。</p>
<h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p>仅当Spring Bean是单例的，才有必要讨论生命周期问题。</p>
<p>在自定义的组件类中，可以自定义方法，并在方法添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，将方法标记为初始化方法和销毁方法。</p>
<p>在使用<code>@Bean</code>方法的情况下，可以在<code>@Bean</code>注解上配置<code>initMethod</code>和<code>destroyMethod</code>属性，来指定初始化方法和销毁方法的名称。</p>
<p>初始化方法会在创建对象、完成自动装配之后，被Spring框架自动调用。</p>
<p>销毁方法会在Spring框架销毁对象的前一刻被自动调用。</p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>自动装配：当某个属性，或某个被Spring自动调用的方法的参数需要值时，Spring会自动从容器中找到合适的值，为属性或参数注入值。</p>
<p>示例：为属性注入值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：为方法的参数注入值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//                    ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 自动装配</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类中仅有1个构造方法，不需要添加<code>@Autowired</code>注解；如果类中有多个构造方法，Spring会尝试调用无参数的构造方法，如果某个构造方法添加了<code>@Autowired</code>注解，则必然调用添加了注解的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//                        ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 自动装配</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMapper</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//                                   ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 自动装配</span></span><br><span class="line">    <span class="keyword">public</span> UserController <span class="title function_">userController</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">        userController.setUserMapper(userMapper);</span><br><span class="line">        <span class="keyword">return</span> userController;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此以外，通过<code>@Value</code>注解也适用以上做法！</p>
<p>使用<code>@Resource</code>注解也可以实现自动装配，但是，它不可以添加在构造方法上！并且，它是<code>javax</code> 包下的注解！从装配机制上，<code>@Resource</code>是先根据名称装配，再根据类型装配，而<code>@Autowired</code>是先根据类型进行查找，当冲突时再尝试根据名称装配。</p>
<p>关于<code>@Autowired</code>的装配机制，它是先根据类型查找匹配类型的Spring Bean的数量，然后：</p>
<ul>
<li>0个：取决于<code>@Autowired</code>注解的<code>required</code>属性的值<ul>
<li><code>true</code>（默认）：装配失败，加载Spring时抛出<code>NoSuchBeanDefinitionException</code>异常</li>
<li><code>false</code>：放弃装配，但是，后续可能出现NPE</li>
</ul>
</li>
<li>1个：直接装配，且成功</li>
<li>多个：将尝试根据名称进行装配：<ul>
<li>存在名称匹配的：装配成功</li>
<li>不存在名称匹配的：装配失败，加载Spring时抛出<code>NoUniqueBeanDefinitionException</code>异常</li>
</ul>
</li>
</ul>
<p>另外，关于名称匹配：</p>
<ul>
<li>Spring Bean的名称与属性（或参数）的名称相同</li>
<li>属性（或参数）的名称与Spring Bean的名称相同</li>
<li>通过<code>@Resource</code>的<code>name</code>属性指定Spring Bean的名称；通过<code>@Qulifier</code>注解指定Spring Bean的名称，结合<code>@Autowired</code>的机制一起使用</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>IoC（Inversion of Control）：控制反转，指的是将对象的创建、管理等控制权交给了框架</p>
<p>DI（Dependency Injection）：依赖注入，为对象的依赖项（类中的属性）注入值</p>
<p>Spring框架通过DI完善了IoC。</p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>再议</p>
<h1 id="Spring-MVC框架"><a href="#Spring-MVC框架" class="headerlink" title="Spring MVC框架"></a>Spring MVC框架</h1><h2 id="Spring-MVC框架的作用"><a href="#Spring-MVC框架的作用" class="headerlink" title="Spring MVC框架的作用"></a>Spring MVC框架的作用</h2><p>Spring MVC框架主要解决了：</p>
<ul>
<li>接收请求</li>
<li>响应结果</li>
<li>处理异常</li>
</ul>
<h2 id="Spring-MVC框架的依赖项"><a href="#Spring-MVC框架的依赖项" class="headerlink" title="Spring MVC框架的依赖项"></a>Spring MVC框架的依赖项</h2><p>Spring MVC框架的基础依赖项是：<code>spring-webmvc</code></p>
<h2 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h2><p>Spring MVC通过控制器中的方法来接收请求。</p>
<p>仅当添加了<code>@Controller</code>注解的组件类会被视为“控制器类”。</p>
<p>需要通过<code>@RequestMapping</code>系列注解来配置请求路径，此系列注解包括：</p>
<ul>
<li><code>@RequestMapping</code></li>
<li><code>@GetMapping</code>，等效于<code>@RequestMapping(method = RequestMethod.GET)</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>通常，以上注解都只需要用于配置请求路径即可，如果响应结果中，中文出现乱码，可以配置注解的<code>produces</code>属性，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;, produces = &quot;application/json; charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a>接收请求参数</h2><h3 id="接收普通参数"><a href="#接收普通参数" class="headerlink" title="接收普通参数"></a>接收普通参数</h3><p>无论是GET请求中在URL中的参数，还是POST请求中在请求体中的参数，你都可以直接声明为处理请求的方法的参数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginParam</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(UserLoginParam userLoginParam)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：以上做法都可以接收到请求参数，特别是第2种封装的做法，在过程中，Spring MVC框架就使用到了Spring框架创建对象的机制，把多个请求参数自动创建为参数类型的对象！</p>
<h3 id="接收URL中占位符的参数"><a href="#接收URL中占位符的参数" class="headerlink" title="接收URL中占位符的参数"></a>接收URL中占位符的参数</h3><p>也可以在设计URL时，使用<code>&#123;&#125;</code>格式的占位符，并结合<code>@PathVariable</code>注解获取占位符位置的值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8080/users/9527/delete</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;/delete&quot;)</span> <span class="comment">// 假设类上已经配置了@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在占位符中的自定义名称右侧，可以添加冒号，再编写正则表达式，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id:[0-9]+&#125;/delete&quot;)</span></span><br></pre></td></tr></table></figure>

<p>如果请求的URL匹配，则对应的方法可以处理请求，如果请求的URL不匹配，则不会匹配！</p>
<p>另外，如果设计的URL中的占位符名称与方法的参数名称不一致，可以配置注解参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;/delete&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于-RequestBody注解"><a href="#关于-RequestBody注解" class="headerlink" title="关于@RequestBody注解"></a>关于<code>@RequestBody</code>注解</h3><p>在处理请求的方法的参数上添加<code>@RequestBody</code>，表示客户端提交的请求参数需要是某种特定格式的，例如是JSON格式或XML格式等。</p>
<p>在没有添加<code>@RequestBody</code>的情况下，客户端提交的请求参数必须是FormData格式的，例如：<code>username=test&amp;password=123456</code>。</p>
<p>结论：</p>
<ul>
<li>有<code>@RequestBody</code>：参数必须是某种格式的，如果是FormData，则抛出<code>HttpMediaTypeNotSupportedException</code>异常</li>
<li>没有<code>@RequestBody</code>：参数必须是FormData的，如果是某种格式的，则服务器端接收到的参数均为<code>null</code></li>
</ul>
<h3 id="关于-RequestParam"><a href="#关于-RequestParam" class="headerlink" title="关于@RequestParam"></a>关于<code>@RequestParam</code></h3><p><code>@RequestParam</code>注解的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestParam &#123;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">defaultValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h2><p>在默认情况下，处理请求的方法的返回值表示“处理响应的视图组件的名称及相关数据”，最终的响应是一个嵌入了数据的完整的HTML页面的源代码，这不是前后端分离的做法！</p>
<p>在前后端分离的开发模式下，服务器端应该只响应数据结果，由客户端自行决定如何处理这些数据！</p>
<p>在处理请求的方法上，添加<code>@ResponseBody</code>注解，即可使得此方法是“响应正文”的，方法的返回值就是响应到客户端的数据，而不再处理视图！</p>
<p>也可以在控制器类上添加<code>@ResponseBody</code>注解，则类中所有方法都是响应正文的！或者，在类上使用<code>@RestController</code>注解，它是由<code>@Controller</code>和<code>@ResponseBody</code>组合而成的注解！</p>
<h2 id="关于HttpMessageConverter"><a href="#关于HttpMessageConverter" class="headerlink" title="关于HttpMessageConverter"></a>关于HttpMessageConverter</h2><p>Spring MVC框架内置了许多消息转换器（MessageConverter），其作用是实现基础数据与对象的相互转换。</p>
<p>在接收请求时，Spring MVC会根据请求头中的<code>Content-Type</code>来识别请求参数的文档类型，然后，自动选择合适的消息转换器，将请求参数转换为对象！</p>
<p>在处理响应时，Spring MVC会根据方法的返回值类型来选择合适的消息转换器，例如，当方法的返回值是<code>String</code>类型，就会使用<code>StringHttpMessageConverter</code>（Spring MVC自带的），如果方法的返回值类型是Spring MVC没有对应的消息转换器的类型时，如果项目中添加了Jackson依赖项时，Spring MVC会自动使用Jackson框架中的消息转换器来处理方法的返回值，而Jackson框架会将返回值转换成JSON格式的数据！</p>
<p>在Spring Boot项目中添加了<code>spring-boot-starter-web</code>时，就包括了Jackson相关的依赖项！</p>
<h2 id="统一处理异常"><a href="#统一处理异常" class="headerlink" title="统一处理异常"></a>统一处理异常</h2><p>在基于Spring MVC框架的Web项目中，应该由控制器中的方法捕获并处理异常，但是，处理不同请求时，可能出现相同的异常，则在多个不同的方法都需要使用<code>try...catch</code>进行捕获并处理，非常繁琐！Spring MVC框架提供了统一处理异常的机制，每个处理请求的方法都不必处理异常，而是将异常抛出即可，Spring MVC会自动使用统一处理异常的机制对这些抛出的异常进行处理！</p>
<p>注意：统一处理异常的机制，只能处理控制器中的方法抛出的异常！</p>
<p>使用统一处理异常机制时：</p>
<ul>
<li>使用专门的类，在类上添加<code>@ControllerAdvice</code>注解，或<code>@RestControllerAdvice</code>注解，则此类中的特定的方法（例如添加了<code>@ExceptionHandler</code>的方法）就可以作用于整个项目中所有控制器类中的所有方法</li>
<li>自定义处理异常的方法，此方法需要添加<code>@ExceptionHandler</code>注解，并且，方法的参数中必须有1个异常类型</li>
</ul>
<p>注意：处理异常的方法，并不像处理请求的方法那样可以自由的添加参数，必须有1个异常类型，并且，可以按需添加少量特定类型的参数，例如<code>HttpServletRequest</code>、<code>HttpServletResponse</code>等，除了特定类型以外的都不可以设计为处理异常的方法的参数！</p>
<hr>
<h1 id="Spring-Boot框架"><a href="#Spring-Boot框架" class="headerlink" title="Spring Boot框架"></a>Spring Boot框架</h1><h2 id="Spring-Boot框架的作用"><a href="#Spring-Boot框架的作用" class="headerlink" title="Spring Boot框架的作用"></a>Spring Boot框架的作用</h2><p>Spring Boot框架主要解决了：依赖管理，自动配置</p>
<p>Spring Boot被设计为“开箱即用”的，它是一种“约定大于配置”的思想。</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>在开发实践中，需要使用到的依赖项很多，而且，添加的某个依赖项可能还依赖了其它依赖项，例如，当添加<code>spring-webmvc</code>时，<code>spring-webmvc</code>还依赖了<code>spring-context</code>，另外，再添加<code>spring-jdbc</code>时，<code>spring-jdbc</code>也会依赖<code>spring-context</code>，如果<code>spring-webmvc</code>和<code>spring-jdbc</code>依赖的<code>spring-context</code>的版本并不相同，则项目是不可用的。</p>
<p>所以，众多依赖项必须是协调的，版本应该兼容且不冲突，Spring Boot项目都使用了<code>spring-boot-starter-parent</code>作为父级项目，这个父级项目就管理了许多依赖项的版本，所以，在<code>pom.xml</code>中添加依赖时，某些依赖项是不需要写版本号的，并且，它提供大量了<code>spring-boot-starter-???</code>的依赖项，例如<code>spring-boot-starter-web</code>，这些依赖项会将相关的一组依赖整合在一起，开发者添加依赖时更加方便！</p>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>在<code>spring-boot-starter</code>依赖项中包含了<code>spring-boot-autoconfigure</code>，这个<code>spring-boot-autoconfigure</code>就是用于实现自动配置的，其中包含了大量的、预编写的自动配置类，这些自动配置类中使用了<code>@ConditionalOnXxx</code>系列的注解，对当前项目的环境（是否添加了哪些依赖、是否创建了哪些对象、是否配置了哪些属性等）进行判断，以决定是否需要启用某些自动配置。</p>
<p>另外，其实需要通过<code>@EnableAutoConfiguration</code>注解来开启自动配置，此注解已经被包含在<code>@SpringBootApplication</code>中了，所以，并不需要显式的使用此注解！</p>
<h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><ul>
<li><code>@Spri                                                                                                                                      ngBootApplication</code>：添加在启动类上，每个Spring Boot项目只能有1个类添加此注解</li>
<li><code>@SpringBootConfiguration</code>：包含了<code>@Configuration</code>，被包含在<code>@SpringBootApplication</code>中</li>
<li><code>@SpringBootTest</code>：标记某个类是基于Spring Boot的测试类，执行这个类中的测试方法时，会加载Spring Boot的所有环境，包括执行组件扫描、读取配置文件等</li>
</ul>
<h1 id="Spring-Security框架"><a href="#Spring-Security框架" class="headerlink" title="Spring Security框架"></a>Spring Security框架</h1><h2 id="Spring-Security框架的作用"><a href="#Spring-Security框架的作用" class="headerlink" title="Spring Security框架的作用"></a>Spring Security框架的作用</h2><p>Spring Security框架主要解决了认证与授权的相关问题。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>认证：识别客户端的身份，Spring Security只会根据<code>SecurityContext</code>中的认证信息（<code>Authentication</code>对象）来识别客户端的身份</p>
<p>授权：控制客户端是否允许访问某个资源</p>
<p>提示：登录是处理认证时非常重要且不可或缺的一个环节，在处理登录时，需要将通过登录验证后的结果（认证信息）存入到<code>SecurityContext</code>中，后续，Spring Security会自动从<code>SecurityContext</code>中找到认证信息，从而识别客户端的身份</p>
<h2 id="Spring-Security框架的基本特点"><a href="#Spring-Security框架的基本特点" class="headerlink" title="Spring Security框架的基本特点"></a>Spring Security框架的基本特点</h2><p>在Spring Boot项目中，当添加了<code>spring-boot-starter-security</code>依赖后，你的项目会发生以下变化：</p>
<ul>
<li>所有请求都是必须通过认证的，否则，会响应<code>403</code>，或重定向到默认的登录页面</li>
<li>提供了默认的登录页（<code>/login</code>）和登出页（<code>/logout</code>）</li>
<li>提供了默认的登录账号，用户名为<code>user</code>，密码为启动项目时的控制台提示的UUID值</li>
<li>默认开启了防止伪造的跨域攻击的防御机制，自定义的POST请求无法正常处理</li>
</ul>
<h2 id="关于Spring-Security的配置类"><a href="#关于Spring-Security的配置类" class="headerlink" title="关于Spring Security的配置类"></a>关于Spring Security的配置类</h2><p>在项目中，可以自定义类，继承自<code>WebSecurityConfigurerAdapter</code>，则此类是Spring Security的配置类，在类中重写<code>void configure(HttpSecurity http)</code>方法进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置请求的授权访问，注意：将使用第一匹配原则</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/user/reg&quot;</span>) <span class="comment">// 匹配若干个路径，可以使用Ant-Style通配模式</span></span><br><span class="line">            .permitAll() <span class="comment">// 允许直接访问，不需要检查认证信息</span></span><br><span class="line">            .anyRequest() <span class="comment">// 所有请求，也可以视为“除了以上配置过的以外的其它请求”</span></span><br><span class="line">            .authenticated(); <span class="comment">// 要求是已经通过认证的，则需要检查认证信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果调用以下方法，将启用默认的登录页和登出页，当视为“未通过认证”时，将重定向到登录页</span></span><br><span class="line">        <span class="comment">// 如果不调用以下方法，将不启用默认的登录页和登录页，当视为“未通过认证”时，将响应403</span></span><br><span class="line">        <span class="comment">// 还可以在以下方法的基础上，进一步调用其它方法对登录页和登出页进行配置</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 禁用【防止伪造的跨域攻击的防御机制】，则自定义的POST请求可以正常处理</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Ant-Style：</p>
<ul>
<li>当使用<code>*</code>通配符时，例如：<code>/user/*</code>，可以匹配<code>/user/login</code>，但不可以匹配<code>/user/9527/delete</code></li>
<li>当使用<code>**</code>通配符时，例如：<code>/user/**</code>，可以匹配<code>/user/login</code>，也可以匹配<code>/user/9527/delete</code></li>
</ul>
<p>关于第一匹配原则：</p>
<ul>
<li>如果某个请求匹配以上配置的多种规则，将以第一次匹配到的为准，根据以上演示代码，<code>/user/login</code>匹配到了<code>mvcMatcher()</code>方法配置的路径，也匹配了<code>anyRequest()</code>，由于<code>mvcMatcher()</code>的代码靠前，则<code>/user/login</code>请求适用于<code>permitAll()</code>，而不会是<code>authenticated()</code>，在实际应用中，可以简单的认为：需要将精准的配置写在靠前的位置，需要将模糊的配置写在靠后的位置</li>
</ul>
<h2 id="使用Spring-Security验证登录"><a href="#使用Spring-Security验证登录" class="headerlink" title="使用Spring Security验证登录"></a>使用Spring Security验证登录</h2><p>Spring Security提供了<code>UserDetailsService</code>接口，接口中定义了<code>UserDetails loadUserByUsername(String username)</code>方法，在验证登录时，Spring Security框架会自动使用登录时提交的用户名来调用这个方法，则框架将得到返回的<code>UserDetails</code>类型的对象，并自动检查<code>UserDetails</code>对象中的用户状态，如果用户状态为不可用（被禁用、已过期等），则抛出异常，然后，还会自动验证登录时提交的密码与<code>UserDetails</code>对象中的密码是否匹配，如果不匹配，则抛出异常，如果匹配，则验证完成，将返回<code>Authentication</code>类型的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设提交了登录信息：root / 123456</span><br><span class="line"></span><br><span class="line">【以下是框架自动执行】</span><br><span class="line">UserDetails userDetails = userDetailsService.loadUserByUsername(&quot;root&quot;);</span><br><span class="line">检查userDetails对象中包含的用户状态，例如是否禁用、是否过期等</span><br><span class="line">检查userDetails对象中包含的密码，与123456是否匹配</span><br></pre></td></tr></table></figure>

<p>当需要自定义登录验证时，需要：</p>
<ul>
<li><p>在配置类中，使用<code>@Bean</code>方法配置密码编码器（<code>PasswordEncoder</code>）</p>
<ul>
<li>Spring Security在验证密码是否匹配时，要求<code>UserDetails</code>类型的对象中的密码是某种密文格式</li>
<li>一般定义在Spring Security的配置类中即可</li>
</ul>
</li>
<li><p>在Spring Security配置类中，通过重写<code>AuthenticationManager authenticationManagerBean()</code>方法，并在方法上添加<code>@Bean</code>注解，则后续可以自动装配<code>AuthenticationManager</code>对象来执行登录验证</p>
<ul>
<li>不建议重写<code>authenticationManager()</code>方法，此方法在执行某些测试时会出现死循环，从而导致内存溢出</li>
</ul>
</li>
<li><p>自定义组件类，实现<code>UserDetailsService</code>接口，并重写<code>loadUserByUsername()</code>方法</p>
<ul>
<li>一旦Spring容器中存在<code>UserDetailsService</code>类型的对象，则Spring Security不再启用默认的登录账号，启动项目时控制台也不再显示临时的UUID密码</li>
</ul>
</li>
<li><p>在需要执行登录验证的类中，先自动装配<code>AuthenticationManager</code>，然后再调用此对象的<code>authenticate()</code>方法即可执行登录验证</p>
<ul>
<li>提示：验证通过后，应该将<code>authenticate()</code>方法返回的结果存入到<code>SecurityContext</code>中，以保证后续能够通过认证</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring相关</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2023/08/25/Spring-Cloud-Gateway/</url>
    <content><![CDATA[<h1 id="网关组件springcloud-gateway"><a href="#网关组件springcloud-gateway" class="headerlink" title="网关组件springcloud gateway"></a>网关组件springcloud gateway</h1><h2 id="阶段性架构"><a href="#阶段性架构" class="headerlink" title="阶段性架构"></a>阶段性架构</h2><p>naocs+dubbo 实现的阶段性架构</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822094156489.png" alt="image-20230822094156489" style="zoom:50%;" />

<p>这个当前的架构可以解决微服务分布式集群中任何内部调用的逻辑.但是无法处理外部调用.</p>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822095023449.png" alt="image-20230822095023449" style="zoom:50%;" />

<h2 id="网关组件spring-cloud-gateway基本介绍"><a href="#网关组件spring-cloud-gateway基本介绍" class="headerlink" title="网关组件spring cloud gateway基本介绍"></a>网关组件spring cloud gateway基本介绍</h2><p>网关作为微服务集群唯一的对外入口,可以实现很多功能.</p>
<p>例如: 统一的解决跨域问题,统一的身份认证.如果网关能够结合一些其它的插件 可以实现入口流量控制(sentinel).做到监控预警(Prometheus)等</p>
<p>网关的落地方案(Spring cloud gateway),还有其它选择</p>
<ol>
<li>netflix zuul: 原来比较火的一个网关组件,但是netflix奈飞停更了,zuul2流产了.</li>
<li>Kong: 也是一种选择</li>
<li>Nginx: 反向代理网关,并发能力,速度都可以保证.</li>
</ol>
<p>spring cloud gateway 完成的具体功能</p>
<ul>
<li><p>转发: 网关不具备处理某个请求的能力,所以一定要转发给微服务.</p>
</li>
<li><p>路由(网络端到端的路径<strong>选择</strong>): 根据请求地址,功能判断具体由哪个服务来完成这次处理</p>
</li>
<li><p>过滤: 可以在过滤逻辑中,对请求做自定义的逻辑处理(比如验证身份.记录请求次数)</p>
</li>
</ul>
<p>spring cloud gateway 有什么特点?为什么选择这个组件</p>
<ul>
<li>技术栈完善,支持团队稳定</li>
</ul>
<p>spring cloud ,spring, spring boot</p>
<ul>
<li>性能高</li>
</ul>
<p>Spring cloug gateway 底层是spring webflux netty(nio通信逻辑). 性能超高的.</p>
<p>没有阻塞处理,避免了I&#x2F;O瓶颈.</p>
<ul>
<li>易于扩展和定制</li>
</ul>
<p>spring框架 通用性的问题可以直接解决,定制的问题,他也给你提供接口实现扩展.</p>
<ul>
<li>有些超出当前开发的掌握的习惯和规则</li>
</ul>
<p>spring cloud gateway 基于 springboot spring webflux project reactor实现的,很多当前已经习惯的开发模式 规范,在spring cloud gateway可能不太适用.</p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="需求-转发"><a href="#需求-转发" class="headerlink" title="需求(转发)"></a>需求(转发)</h3><ol>
<li>请求访问网关(网关也是web应用)</li>
<li>网关根据这个请求,做请求的转发 ,转给stock</li>
<li>stock具备处理这个请求的能力</li>
</ol>
<h3 id="案例步骤"><a href="#案例步骤" class="headerlink" title="案例步骤"></a>案例步骤</h3><ul>
<li>创建一个网关maven工程</li>
</ul>
<p>提供依赖资源:</p>
<p>spring-boot-starter-web</p>
<p>gateway依赖</p>
<p>loadbalancer: 网关支持的负载均衡计算组件.</p>
<p>nacos-discovery: 整合nacos</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--由于gateway底层是project reactor和starter-web的tomcat冲突</span></span><br><span class="line"><span class="comment">        两种完全不一样的web容器 我们这里使用属性配置忽略掉冲突的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--转发的案例是不使用nacos的,路由负载均衡的时候才使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常规的启动类(略)</p>
</li>
<li><p>编写转发功能的application.yml文件</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8999</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway-server</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment"># 关闭了tomcat的servlet容器配置 不会和gateway冲突了</span></span><br><span class="line">    <span class="attr">web-application-type:</span> <span class="string">reactive</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#微服务网关</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 当前所有请求进入网关的url都转发给stock</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="comment">#当前配置的没一个元素,都会在网关路由过滤器中添加一个路由对象</span></span><br><span class="line">      <span class="comment">#帮助网关记录请求的路由匹配</span></span><br><span class="line">          <span class="comment"># id 一个路由计算对象的id值,应该保证唯一</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">demo-test</span></span><br><span class="line">          <span class="comment"># uri 转发的目标地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:10012</span></span><br><span class="line">          <span class="comment"># 断言,根据断言的内容和规则,匹配进入网关的请求</span></span><br><span class="line">          <span class="comment"># 如果匹配上,才能由当前路由对象进行计算</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment"># 请求url地址中路径值 满足/**的匹配,就满足这个断言了</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure>

<h3 id="基于案例详细分析请求流转过程-重要-极其重要"><a href="#基于案例详细分析请求流转过程-重要-极其重要" class="headerlink" title="基于案例详细分析请求流转过程(重要,极其重要)"></a>基于案例详细分析请求流转过程(重要,极其重要)</h3><p>案例一:</p>
<ol>
<li>浏览器发送了一个请求: <a href="http://localhost:8999/abc/abc?name=wangcuihua">http://localhost:8999/abc/abc?name=wangcuihua</a></li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> 可以进入网关</li>
</ul>
<ol start="2">
<li>了解请求的url地址组成</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822111748182.png" alt="image-20230822111748182"></p>
<p>http: 协议</p>
<p>localhost: 域名,能够帮助请求访问找到服务器</p>
<p>8999: 端口,找到服务器,找到对应接收请求的端口进程</p>
<p>&#x2F;abc&#x2F;abc: path路径,看成是这个进程可以处理的资源path</p>
<p>?name&#x3D;wang: 请求参数.</p>
<ol start="3">
<li>在网关中,根据path 进行断言的计算</li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> Path&#x3D;&#x2F;** 匹配 &#x2F;abc&#x2F;abc true</li>
<li><input checked="" disabled="" type="checkbox"> Path&#x3D;&#x2F;cba&#x2F;** 匹配 &#x2F;abc&#x2F;abc false</li>
</ul>
<ol start="4">
<li>网关根据匹配断言的结果 true 找到routes 的id(由哪一个路由对象来计算)</li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> demo-test</li>
</ul>
<ol start="5">
<li>根据uri实现转发的落地</li>
</ol>
<p>​	uri: <a href="http://127.0.0.1:10012/">http://127.0.0.1:10012</a></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 将请求path &#x2F;abc&#x2F;abc 拼接到uri中 <a href="http://127.0.0.1:10012/abc/abc?name=wangcuihua">http://127.0.0.1:10012/abc/abc?name=wangcuihua</a></li>
</ul>
<p>​	6 . 网关向外转发了一个请求.</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 当前环境没有人处理这个请求</li>
</ul>
<p>导致网关转发就失败了.</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822112640305.png" alt="image-20230822112640305"></p>
<ol start="7">
<li>网关连接失败,返回500错误信息</li>
</ol>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822112735273.png" alt="image-20230822112735273" style="zoom:50%;" />

<p>案例二:</p>
<p>请求url不变 stock 10012正常启动</p>
<p><a href="http://localhost:8999/abc/abc?name=wangcuihua">http://localhost:8999/abc/abc?name=wangcuihua</a></p>
<p>经过前6步和案例一完全一样的流转逻辑,最终可以连接访问</p>
<p><a href="http://127.0.0.1:10012/abc/abc?name=wangcuihua">http://127.0.0.1:10012/abc/abc?name=wangcuihua</a></p>
<ol>
<li>由于后端服务实例,不具备处理&#x2F;abc&#x2F;abc资源请求,返回404</li>
<li>网关将后端的处理结果返回给客户</li>
<li>客户端浏览器看到404</li>
</ol>
<p>练习案例:</p>
<p><a href="http://localhost:8888/abc/abc">http://localhost:8888/abc/abc</a></p>
<p>没有任何进程处理这个请求</p>
<p><a href="http://localhost:8999/doc.html">http://localhost:8999/doc.html</a></p>
<p>网关转发给<a href="http://127.0.0.1:10012/doc.html">http://127.0.0.1:10012/doc.html</a></p>
<p>如果后端程序有这个资源,正常看到,没有这个资源,依然是404</p>
<p>有接口文档页面资源,所以可以看到</p>
<p><a href="http://localhost:8999/base/stock/reduce/count">http://localhost:8999/base/stock/reduce/count</a></p>
<p>网关转发给<a href="http://127.0.0.1:10012/base/stock/reduce/count">http://127.0.0.1:10012/base/stock/reduce/count</a></p>
<p>如果后端程序有这个资源,正常看到,没有这个资源,依然是404</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822114549204.png" alt="image-20230822114549204"></p>
<h2 id="断言详解"><a href="#断言详解" class="headerlink" title="断言详解"></a>断言详解</h2><p>断言 predicates: 没有路由配置必备的一个属性.</p>
<p>作用: 实现一个进入网关请求的mapping映射计算的.</p>
<p>断言的方式,计算的功能,除了Path以外,有很多种.</p>
<p>多种断言可以独立配置,也可以组合使用.</p>
<p><strong>注意</strong>: 配置yaml值,语法中注意&#x3D;的使用,前后不能有空格.</p>
<h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>案例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After</span> <span class="string">=</span> <span class="number">2017-01-20T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure>

<p>所有请求进入网关满足After的判断的,都会匹配这个叫做after_route的路由.</p>
<p>在某个具体的时间点之后的请求.</p>
<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>所有请求在这个时间点之前的,都满足匹配这个路由.</p>
<h3 id="Between"><a href="#Between" class="headerlink" title="Between"></a>Between</h3><p>使用after+before也能实现between的功能.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-21T17:42:47.789-07:00[America/Denver]</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure>

<p>在两个时间点之间的请求满足断言匹配当前路由</p>
<p>以上的3断言和访问时间有关.</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate,</span> <span class="string">abc</span></span><br></pre></td></tr></table></figure>

<p>要求请求必须携带一个cookie值,名字叫chocolate ,value值 必须满足 {ch.p}正则表达</p>
<p>式. 如果断言的的值不是正则,就是一个固定值,就是判断相等.</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<p>匹配请求必须携带一个头 ,名字为X-Request-Id,头的值满足正则 \d+(一个或者多个数字);</p>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=green</span></span><br></pre></td></tr></table></figure>

<p>请求中要有?green这个值,就满足断言匹配</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=green,red</span></span><br></pre></td></tr></table></figure>

<p>请求中要有?green&#x3D;red满足断言的匹配</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br></pre></td></tr></table></figure>

<p>请求Host头,如果是 <a href="http://www.somehost.org/">www.somehost.org</a>; order.somehost.org; cart.somehost.org;</p>
<p>主域名(一级域名): jd.com;taobao.com</p>
<p>二级域名: <strong>passport</strong>.jd.com;<strong>login</strong>.taobao.com</p>
<p>三级域名:<strong>aa</strong>.passport.jd.com;<strong>bb</strong>.passport.jd.com</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<p>请求方式必须是GET或者POST其中一个,就能满足这个断言要求.</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">path_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>请求的路径 满足&#x2F;red&#x2F;{任意},或者 &#x2F;blue&#x2F;{任意}</p>
<p>同时可以是ANT的匹配字符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>规则</th>
<th>案例</th>
<th>匹配</th>
<th>不匹配</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>匹配单个字符</td>
<td>&#x2F;z&#x2F;?</td>
<td>&#x2F;z&#x2F;a,&#x2F;z&#x2F;b</td>
<td>&#x2F;z&#x2F;ab,&#x2F;z&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
<tr>
<td>*</td>
<td>匹配一级字符串</td>
<td>&#x2F;z&#x2F;*</td>
<td>&#x2F;z&#x2F;abc,&#x2F;z&#x2F;cba</td>
<td>&#x2F;z&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
<tr>
<td>**</td>
<td>匹配一级或多级字符串</td>
<td>&#x2F;z&#x2F;**</td>
<td>&#x2F;z&#x2F;a,&#x2F;z&#x2F;abc,&#x2F;z&#x2F;a&#x2F;b&#x2F;c</td>
<td>&#x2F;<strong>x</strong>&#x2F;a,&#x2F;<strong>y</strong>&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
</tbody></table>
<h3 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure>

<p>在24个字节范围之内,子网掩码(255.255.0.0). 网络地址在此网段满足 断言的</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 192.168.1.10 </li>
<li><input checked="" disabled="" type="checkbox"> 192.168.1.11</li>
<li><input disabled="" type="checkbox"> 192.168.2.10 不匹配</li>
</ul>
<h3 id="Weight"><a href="#Weight" class="headerlink" title="Weight"></a>Weight</h3><p>权重断言</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weighthigh.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weightlow.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>分散的转发了 两个路由(路由匹配规则相同),一批高并发请求,会按照8:2的比例</p>
<p>转发调用到后端不同的服务,实例.</p>
<h3 id="4-0-x-新的断言"><a href="#4-0-x-新的断言" class="headerlink" title="(4.0.x) 新的断言"></a>(4.0.x) 新的断言</h3><p>当前使用gateway是3.0.3 没有</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">xforwarded_remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">XForwardedRemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure>

<p>请求Header 如果是转发(重定向),也有可能在后端处理请求,做重新访问的时候也会出现.</p>
<p>要求头的值必须在这个ip网段范围之内.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>平时我们使用的断言 最多的就2种</p>
<p><strong>第一种</strong> Path</p>
<p>微服务不同服务,请求path路径规则是不一样</p>
<p>比如 </p>
<ul>
<li>- Path&#x3D;&#x2F;order&#x2F;** 表示订单服务</li>
<li>- Path&#x3D;&#x2F;cart&#x2F;** 购物车服务</li>
</ul>
<p><strong>第二种</strong> Host</p>
<p>微服务集群搭建,每个服务都独占一个域名</p>
<p>比如</p>
<ul>
<li>- Host&#x3D;cart.csmall.com 购物车</li>
<li>- Host&#x3D;search.csmall.com 搜索</li>
</ul>
<h2 id="路由负载均衡"><a href="#路由负载均衡" class="headerlink" title="路由负载均衡"></a>路由负载均衡</h2><h3 id="利用断言和路由映射关系实现负载均衡"><a href="#利用断言和路由映射关系实现负载均衡" class="headerlink" title="利用断言和路由映射关系实现负载均衡"></a>利用断言和路由映射关系实现负载均衡</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">stock-10002</span></span><br><span class="line">	  <span class="attr">uri:</span> <span class="string">http://localhost:10002</span></span><br><span class="line">	  <span class="attr">predicates:</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Path=/stock/**</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">1</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">stock-10012</span></span><br><span class="line">	  <span class="attr">uri:</span> <span class="string">http://localhost:10012</span></span><br><span class="line">	  <span class="attr">predicates:</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Path=/stock/**</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">1</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">stock-10022</span></span><br><span class="line">	  <span class="attr">uri:</span> <span class="string">http://localhost:10022</span></span><br><span class="line">	  <span class="attr">predicates:</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Path=/stock/**</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">1</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">stock-10032</span></span><br><span class="line">	  <span class="attr">uri:</span> <span class="string">http://localhost:10042</span></span><br><span class="line">	  <span class="attr">predicates:</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Path=/stock/**</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">1</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">stock-10042</span></span><br><span class="line">	  <span class="attr">uri:</span> <span class="string">http://localhost:10052</span></span><br><span class="line">	  <span class="attr">predicates:</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Path=/stock/**</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这样做不合理,负载均衡是静态配置,而不是动态分布.</p>
<p>要利用nacos注册信息(动态),实现网关loadbalance负载均衡计算.</p>
<p>要将网关整合到nacos</p>
<h3 id="整合nacos实现负载均衡"><a href="#整合nacos实现负载均衡" class="headerlink" title="整合nacos实现负载均衡"></a>整合nacos实现负载均衡</h3><p>架构图:</p>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822152201187.png" alt="image-20230822152201187"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 引入网关工程 nacos客户端组件</li>
<li><input checked="" disabled="" type="checkbox"> 网关本身不具备负载均衡计算能力,引入负载均衡 网关gateway支持 loadbalancer</li>
<li><input checked="" disabled="" type="checkbox"> 在网关配置nacos的服务端信息</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">				<span class="comment"># 网关没有注册的必要</span></span><br><span class="line">				<span class="attr">register-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<ul>
<li><input checked="" disabled="" type="checkbox"> 修改一下网关路由的配置uri</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway-server</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment"># 关闭了tomcat的servlet容器配置 不会和gateway冲突了</span></span><br><span class="line">    <span class="attr">web-application-type:</span> <span class="string">reactive</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#nacos注册关闭,避免启动失败</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">register-enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#微服务网关</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 当前所有请求进入网关的url都转发给stock</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="comment">#当前配置的没一个元素,都会在网关路由过滤器中添加一个路由对象</span></span><br><span class="line">      <span class="comment">#帮助网关记录请求的路由匹配</span></span><br><span class="line">          <span class="comment"># id 一个路由计算对象的id值,应该保证唯一</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">demo-test01</span></span><br><span class="line">          <span class="comment"># uri lb 表示负载均衡计算 luban-demo-stock 目标服务</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://luban-demo-stock</span></span><br><span class="line">          <span class="comment"># 断言,根据断言的内容和规则,匹配进入网关的请求</span></span><br><span class="line">          <span class="comment"># 如果匹配上,才能由当前路由对象进行计算</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment"># 请求url地址中路径值 满足/**的匹配,就满足这个断言了</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure>

<p>测试:</p>
<p><a href="http://localhost:8999/base/stock/reduce/count?commodityCode=PC100&reduceCount=5">http://localhost:8999/base/stock/reduce/count?commodityCode=PC100&amp;reduceCount=5</a></p>
<h3 id="负载均衡调用流程"><a href="#负载均衡调用流程" class="headerlink" title="负载均衡调用流程"></a>负载均衡调用流程</h3><ol>
<li>浏览器 发送请求</li>
</ol>
<p><a href="http://localhost:8999/base/stock/reduce/count?commodityCode=PC100&reduceCount=5">http://localhost:8999/base/stock/reduce/count?commodityCode=PC100&amp;reduceCount=5</a></p>
<ol start="2">
<li>网关接收请求</li>
<li>利用网关配置的路由断言规则,计算当前请求匹配到的所有路由</li>
<li>匹配到Path&#x3D;&#x2F;** demo-test的路由规则</li>
<li>路由过滤器通过路由uri 找到目标访问地址: lb:&#x2F;&#x2F;luban-demo-stock</li>
<li>调用当前网关负载均衡计算器loadbalancer luban-demo-stock</li>
<li>计算器利用nacos-client抓取的注册信息 找到luban-demo-stock</li>
<li>得到服务下所有的实例集合 List&lt;ServiceInstance&gt;</li>
<li>做负载均衡计算得到一个本次请求需要用到的具体服务实例 假设10002</li>
<li>结果返回给路由过滤器 <a href="http://127.0.0.1:10002/base/stock/reduce/count?commodityCode=PC100&reduceCount=5">http://127.0.0.1:10002/base/stock/reduce/count?commodityCode=PC100&amp;reduceCount=5</a></li>
<li>调用远程代理,实现远程访问</li>
<li>10002的stock实例接收到请求,处理请求,将响应返回</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230822154512997.png" alt="image-20230822154512997"></p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>gateway 专门为微服务结构,准备了一个 动态服务路由的配置逻辑.</p>
<p>使用所有的服务名称作为前缀 - Path&#x3D;&#x2F;{service.name}&#x2F;**.</p>
<p>映射不同的路由规则,然后即将访问出去之前,将服务名称过滤掉.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8999</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway-server</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment"># 关闭了tomcat的servlet容器配置 不会和gateway冲突了</span></span><br><span class="line">    <span class="attr">web-application-type:</span> <span class="string">reactive</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#nacos注册关闭,避免启动失败</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">register-enabled:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="comment">#微服务网关</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#动态路由定位器</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>动态路由的流转详细过程</p>
<p>案例一:</p>
<p>请求地址: <a href="http://localhost:8999/luban-demo-cart/doc.html">http://localhost:8999/luban-demo-cart/doc.html</a></p>
<p>当我们在网关中配置 动态路由后. 网关会根据nacos抓取的服务信息,自动配置路由</p>
<p>当前环境抓取到两个服务 luban-demo-stock luban-demo-cart</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">luban-demo-stock</span></span><br><span class="line">   <span class="attr">uri:</span> <span class="string">lb://luban-demo-stock</span></span><br><span class="line">   <span class="attr">predicates:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">Path=/luban-demo-stock/**</span></span><br><span class="line">   <span class="attr">filters:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">luban-demo-cart</span></span><br><span class="line">   <span class="attr">uri:</span> <span class="string">lb://luban-demo-cart</span></span><br><span class="line">   <span class="attr">predicates:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">Path=/luban-demo-cart/**</span></span><br><span class="line">   <span class="attr">filters:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>url <a href="http://localhost:8999/luban-demo-cart/doc.html">http://localhost:8999/luban-demo-cart/doc.html</a></li>
<li>进入网关</li>
<li>匹配断言满足-Path &#x3D; &#x2F;luban-demo-cart&#x2F;**</li>
<li>找到路由规则id luban-demo-cart</li>
<li>负载均衡计算 lb:&#x2F;&#x2F;luban-demo-cart 10005 10015 10025其中一个</li>
<li><a href="http://localhost:10015/luban-demo-cart/doc.html">http://localhost:10015/luban-demo-cart/doc.html</a></li>
<li>过滤器计算 将第一个路径省略</li>
<li><a href="http://localhost:10015/doc.html">http://localhost:10015/doc.html</a></li>
</ol>
<h1 id="网关CORS"><a href="#网关CORS" class="headerlink" title="网关CORS"></a>网关CORS</h1><h2 id="跨域访问问题"><a href="#跨域访问问题" class="headerlink" title="跨域访问问题"></a>跨域访问问题</h2><p>通过前端请求,发起向后的访问,如果访问的origin原地址和目标地址 </p>
<p><strong>域名</strong>  <strong>ip</strong>  <strong>端口</strong>  <strong>协议</strong> 有一个不一样的,就会形成跨域,默认 springmvc web应用需要后端处理跨域问题的</p>
<table>
<thead>
<tr>
<th>源</th>
<th>目标</th>
<th>是否跨域</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.aa.com/">www.aa.com</a></td>
<td><a href="http://www.bb.com/">www.bb.com</a></td>
<td>true</td>
</tr>
<tr>
<td>cart.aa.com</td>
<td>order.aa.com</td>
<td>true</td>
</tr>
<tr>
<td><a href="http://www.aa.com/">http://www.aa.com</a></td>
<td><a href="https://www.aa.com/">https://www.aa.com</a></td>
<td>true</td>
</tr>
<tr>
<td><a href="http://www.aa.com:8080/">http://www.aa.com:8080</a></td>
<td><a href="http://www.aa.com/">http://www.aa.com</a></td>
<td>true</td>
</tr>
<tr>
<td><a href="http://www.aa.com/">http://www.aa.com</a></td>
<td><a href="http://119.110.112.113/">http://119.110.112.113</a></td>
<td>true</td>
</tr>
</tbody></table>
<h2 id="网关做跨域处理"><a href="#网关做跨域处理" class="headerlink" title="网关做跨域处理"></a>网关做跨域处理</h2><p>gateway提供了一个内部CorsConfiguration配置类,所需要用到的属性</p>
<p>全部都可以在yaml文件中配置.</p>
<p>之前配置类WebMVCConfigurer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">    registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">            .maxAge(<span class="number">3600</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addMapping(“&#x2F;**”): 对进入的哪些资源范围做跨域的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addMapping(<span class="string">&quot;/abc/**&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>allowedHeaders(“*”): 允许origin源 携带到当前服务的头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allowedHeaders(<span class="string">&quot;Accept&quot;</span>,<span class="string">&quot;X-Request-Header&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>allowedMethods(“*”): 允许origin源跨域的请求方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allowedMethods(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>allowedOriginPatterns(“*”): 允许origin头中域名的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allowedOriginPatterns(<span class="string">&quot;**.csmall.com&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>allowCredentials(true): 是否允许携带验证票据 也是限制跨域是否携带头</p>
<p>maxAge(3600): 每次跨域大多数访问逻辑,先发起一个OPTIONS验证,验证是否允许跨域.如果验证成功,后续请求就不再发送OPTIONS验证了,但是持续时间maxAge.</p>
<p>在网关中可以配置yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway-server</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment"># 关闭了tomcat的servlet容器配置 不会和gateway冲突了</span></span><br><span class="line">    <span class="attr">web-application-type:</span> <span class="string">reactive</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#nacos注册关闭,避免启动失败</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">register-enabled:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="comment">#微服务网关</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#动态路由定位器</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">cors-configurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="comment">#- &quot;www.csmall.com&quot;</span></span><br><span class="line">              <span class="comment">#- &quot;www.luban.com&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="comment">#- &quot;Accept&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="comment">#- &quot;GET&quot;</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">7200</span></span><br></pre></td></tr></table></figure>

<h1 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h1><p>除了内置的过滤逻辑,允许我们开发者对网关过滤器功能做扩展.</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>每一个web应用,都可以存在过滤器和拦截器. <strong>springmvc中页过滤器和拦截器</strong>(gateway的过滤器概念和逻辑是相似的,但是代码,使用习惯,编码api相当不相同)</p>
<p><strong>特点:</strong></p>
<ul>
<li>各司其职</li>
<li>顺序执行</li>
<li>特殊情况下可以实现拦截</li>
</ul>
<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230823093639951.png" alt="image-20230823093639951" style="zoom: 50%;" />

<h2 id="入门的gateway过滤器案例"><a href="#入门的gateway过滤器案例" class="headerlink" title="入门的gateway过滤器案例"></a>入门的gateway过滤器案例</h2><p>在网关中添加过滤器,并使其生效的方法步骤</p>
<ol>
<li>创建类,实现接口</li>
<li>spring容器bean对象管理</li>
</ol>
<h3 id="创建过滤器类"><a href="#创建过滤器类" class="headerlink" title="创建过滤器类"></a>创建过滤器类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tarena.luban.demo.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter01</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 交换机spring webflux框架 包装了请求和响应的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 过滤链的对象,处理完过滤逻辑,到底要如何整合回过滤链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Mono 纯粹的spring webflux(函数式编程 lamda) 在这只关注如何用api生成对应Mono</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求进入到过滤器01&quot;</span>);</span><br><span class="line">        <span class="comment">//执行完过滤逻辑,允许请求继续向下 向后</span></span><br><span class="line">        Mono&lt;Void&gt; filter = chain.filter(exchange);</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只在请求进入过滤器时,做了打印标识.</p>
<h3 id="自定义全局过滤器位置"><a href="#自定义全局过滤器位置" class="headerlink" title="自定义全局过滤器位置"></a>自定义全局过滤器位置</h3><p>当前网关 有几个大的模块 他们的顺序</p>
<ol>
<li>通过断言做映射计算找到路由配置</li>
<li>根据路由配置 计算uri访问方式</li>
<li>如果lb协议 需要负载均衡计算器</li>
<li>如果http协议直接向后调用</li>
<li><strong>调用之前</strong>,会进入我们自定义的过滤器</li>
</ol>
<h2 id="过滤器的其它一些功能"><a href="#过滤器的其它一些功能" class="headerlink" title="过滤器的其它一些功能"></a>过滤器的其它一些功能</h2><h3 id="使用案例1"><a href="#使用案例1" class="headerlink" title="使用案例1"></a>使用案例1</h3><p>需求: 拿到请求和响应对象,从请求对象里,获取路由计算结果path.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请求进入到过滤器01&quot;</span>);</span><br><span class="line">    <span class="comment">//exchange.getSession();</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> request.getURI();</span><br><span class="line">    System.out.println(<span class="string">&quot;URI:&quot;</span>+uri.toString());</span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath();</span><br><span class="line">    System.out.println(<span class="string">&quot;path:&quot;</span>+path.toString());</span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="comment">//执行完过滤逻辑,允许请求继续向下 向后</span></span><br><span class="line">    Mono&lt;Void&gt; filter = chain.filter(exchange);</span><br><span class="line">    <span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用url测试访问: <a href="http://localhost:8999/luban-demo-stock/abc">http://localhost:8999/luban-demo-stock/abc</a></p>
<p>打印uri: <a href="http://localhost:8999/abc">http://localhost:8999/abc</a></p>
<p>打印path:&#x2F;abc</p>
<h3 id="使用案例2"><a href="#使用案例2" class="headerlink" title="使用案例2"></a>使用案例2</h3><p>需求: 可以判断一下请求是否携带了一个参数query 名字 叫token </p>
<p>如果携带了,放行,过滤器向后调用,如果没有携带.在这个过滤器拦截这个请求.</p>
<p>扩展(结合之前JWT的流程,在网关过滤器中验证解析JWT,如果解析成功,通过,没成功拦截返回未登录的提示);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请求进入到过滤器01&quot;</span>);</span><br><span class="line">    <span class="comment">//案例1的逻辑 ,从request获取path uri</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> request.getURI();</span><br><span class="line">    System.out.println(<span class="string">&quot;URI:&quot;</span>+uri.toString());</span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath();</span><br><span class="line">    System.out.println(<span class="string">&quot;path:&quot;</span>+path.toString());</span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="comment">//案例2的逻辑 ?name=wang&amp;jobs%5B0%5D=police&amp;jobs%5B1%5D=docter</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">    <span class="comment">// name List&lt;String&gt; 元素是一个 值是wang</span></span><br><span class="line">    <span class="comment">// jobs List&lt;String&gt; 元素有2个 0 police 1 docter</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> queryParams.containsKey(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (exists)&#123;</span><br><span class="line">        <span class="comment">//存在则合法</span></span><br><span class="line">        Mono&lt;Void&gt; filter = chain.filter(exchange);</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为了防止乱码 contentType &quot;application/json;charset=utf-8&quot;</span></span><br><span class="line">        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        <span class="comment">//TODO 一般返回一个Result对象</span></span><br><span class="line">        <span class="comment">//response响应数据 输出回客户端</span></span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.fromSupplier(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;DataBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> DataBuffer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//响应体的字符串</span></span><br><span class="line">                String json=<span class="string">&quot;你没有携带token&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                        response.bufferFactory().wrap(</span><br><span class="line">                                json.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用案例3"><a href="#使用案例3" class="headerlink" title="使用案例3"></a>使用案例3</h3><p>需求: 定义myfilter01和myfilter02过滤器执行的先后顺序</p>
<p>两个过滤器同时生效要不要考虑先后执行的顺序问题?</p>
<ul>
<li>实心ordered接口 定义执行顺序</li>
</ul>
<p>可以在过滤器类上实现接口Ordered.定义每个过滤器具体顺序</p>
<p>需要实现一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//二进制长什么样 1 31个0</span></span><br><span class="line">    <span class="comment">//32个1 -1</span></span><br><span class="line">    <span class="comment">//最大正整数2进制 31位个1</span></span><br><span class="line">    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值 整数,值越小,执行顺序越靠前.</p>
<p>如果值相同(只在测试的时候做),将会判断bean对象的id字符串顺序</p>
<p>0123456789 ABCDEFG…Z abcdefg…z</p>
<p>底层调用的是compare方法实现.</p>
<p>myfilter01 &lt; myfilter02</p>
<ul>
<li>getOrder的赋值特点</li>
</ul>
<p>order顺序值,为了方便扩展,为了方便代码更新迭代</p>
<p>一般都不使用顺序数值 1 2 3 4 5 6 7 8 9 10</p>
<p>提供一个递增的step步数 0 100 200 300 400 500  550 600 700</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>结合之前登录认证流程,在网关中的过滤器应该执行编写什么样的逻辑?完成什么样的功能?存在什么样的问题?</p>
<h3 id="登录认证流程"><a href="#登录认证流程" class="headerlink" title="登录认证流程"></a>登录认证流程</h3><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230823114511269.png" alt="image-20230823114511269" style="zoom: 67%;" />

<h3 id="有了网关登录认证流程"><a href="#有了网关登录认证流程" class="headerlink" title="有了网关登录认证流程"></a>有了网关登录认证流程</h3><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/image-20230823115218588.png" alt="image-20230823115218588" style="zoom:67%;" />

<p>加入网关之后,可以利用网关的过滤器逻辑,实现统一的身份验证(JWT解析).</p>
<p>存在的问题:</p>
<ol>
<li>当初的后端解析,可以实现认证的,因为解析jwt之后拿到用户身份信息</li>
<li>现在网关解析jwt,解析结果如果不传递给后端服务,后端是无法进行认证(不知道订单是谁的,不知道购物车是谁的.)</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/gateway.png"></p>
]]></content>
      <categories>
        <category>微服务相关组件</category>
      </categories>
  </entry>
  <entry>
    <title>常用配置</title>
    <url>/2023/08/19/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Resources下的Mappers"><a href="#Resources下的Mappers" class="headerlink" title="Resources下的Mappers"></a>Resources下的Mappers</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;具体Mapper&quot;</span>&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h1 id="配置数据库连接-properties"><a href="#配置数据库连接-properties" class="headerlink" title="配置数据库连接(properties)"></a>配置数据库连接(properties)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/数据库名?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">    </span><br><span class="line"># 设置MyBatis框架的映射（Mapper）配置文件的位置</span><br><span class="line">mybatis.mapper-locations=classpath:mappers<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure>

<h1 id="配置数据库连接-yaml"><a href="#配置数据库连接-yaml" class="headerlink" title="配置数据库连接(yaml)"></a>配置数据库连接(yaml)</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 设置MyBatis-plus框架的映射（Mapper）配置文件的位置  </span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mappers/*.xml</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用配置</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2023/08/26/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><code>ThreadLocal</code>并不是一个Thread,而是Thread的局部变量</p>
<p><code>ThreadLocal</code>为每个线程提供单独的一份存储空间,具有线程隔离的效果,只有在线程内才能获取到对应的值,线程外则不能访问.</p>
<p>客户端每发送的一次请求都是一个线程</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ul>
<li><p>public void set(T value)  根据当前线程的线程局部变量的值</p>
</li>
<li><p>public T get()                    返回当前线程对应的线程局部变量的值</p>
</li>
<li><p>public void remove()       移除当前线程的线程局部变量</p>
</li>
</ul>
<h2 id="通常封装成工具类来使用"><a href="#通常封装成工具类来使用" class="headerlink" title="通常封装成工具类来使用"></a>通常封装成工具类来使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用工具和框架</category>
      </categories>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2023/11/29/Test/</url>
    <content><![CDATA[<img src="https://cdn.staticaly.com/gh/sanpoi6/markdown_pic@main/2023/8/19/%E5%B1%82%E6%AC%A1.png" style="zoom:33%;" />
]]></content>
  </entry>
  <entry>
    <title>数据库中的索引</title>
    <url>/2023/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="数据库中的索引"><a href="#数据库中的索引" class="headerlink" title="数据库中的索引"></a>数据库中的索引</h1><p>在关系型数据库中，索引（index）是一种单独的、物理层面的对数据库中的一列或多列的值进行排序检索的一种数据结构。</p>
<p>在关系型数据库中，查询数据的效率其实非常低下，在没有做任何优化处理的情况下，查询时，会将表中所有数据全部检查一遍，看每一条数据是否匹配查询条件，所以，数据量越大，查询耗时就越久！并且，数据在磁盘上并不是连接排列的，而是分散在硬盘的不同区域的，所以，进一步导致查询效率低下！</p>
<p>使用索引可以非常明显的提升查询效率！</p>
<p>如果需要手动创建索引，需要自行执行创建索引的SQL语句，其命令基本格式大致是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (field_name);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_name ON mall_category (name);</span><br></pre></td></tr></table></figure>

<p>提示：如果表中已经存在数据，数据量越大，创建索引的耗时就越久！</p>
<p>如果需要删除已经存在的索引，其命令基本格式大致是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<p>在创建索引时，MySQL会将对应的字段的数据进行排序，并在索引中记录下每条数据的位置信息，所以，索引相当于“书的目录”，后续，当需要根据此字段查询数据时，会先翻“书的目录”，找出数据对应的“页码”，并直接翻到对应的“那一页”，就可以把数据找出来了！所以，使用索引后，查询效率会非常高！</p>
<p>索引的本质是一种B+Tree结构（是一种树型结构）的数据，在MySQL中，InnoDB存储引擎中页的大小是16KB，如果使用BIGINT类型的主键，每个主键需要占用8Byte，在B+Tree中的指针是4~8Byte，所以，每个指针与主键形成1个B+Tree中的节点，每个节点最多占用16Byte，每页最少可以存储1024个节点，深度为3的B+Tree最少可以存储1024 * 1024 * 1024个节点，大约是1000 * 1000 * 1000 &#x3D; 1000000000个节点（10亿），所以，每个B+Tree可以维护约10亿个节点，即10亿个“内容与页码”的对应关系，如果表中的数据量不超过约10亿条，都只需要执行3次IO操作，就可以找出数据的位置。</p>
<p>在数据库中，即使你没有显式的创建索引，某个字段的查询效率可能也非常高，是因为索引有多种：</p>
<ul>
<li>PRIMARY KEY：主键索引</li>
<li>UNIQUE：唯一索引</li>
<li>INDEX：普通索引</li>
<li>FULLTEXT：全文索引</li>
</ul>
<p>基于索引的数据结构的特性，在使用时，必须注意：</p>
<ul>
<li>索引不会包含有NULL值的列</li>
<li>数据量非常少的表没有必要创建索引，索引也需要维护，并占用一定的存储空间</li>
<li>数据经常变化的字段不要创建索引，因为，数据的变化可能需要同步更新索引，导致写数据的效率降低</li>
<li>查询时需要计算字段的值时，索引是无效的（不会发挥作用），例如：<code>where age / 10 &gt; 8</code>时，<code>age</code>列的索引就是无效的</li>
<li>左侧的模糊查询无法使用索引，因为索引是基于这一列的数据进行排序得到的，如果执行左侧模糊查询，则排序是无意义的，所有数据都需要被检查是否匹配<ul>
<li>在开发实践中，几乎不使用模糊查询</li>
</ul>
</li>
</ul>
<p>除了以上限制以外，不同的企业可能有更高的要求：</p>
<ul>
<li>类别为<code>text</code>的字段不允许使用索引</li>
<li>类别为<code>varchar</code>且字段值可能很长的字段不允许使用索引</li>
</ul>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
  </entry>
</search>
